#!/usr/bin/env bash

##  qqX component to be located in folder 'qqX.main'

##  Copyright (c)  Alex Genovese   https://github.com/qqxproject
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.
# 	Otherwise:
#   Licence  GPL3   https://www.gnu.org/licenses
##  qqX - quickemu quickget X terminal project

## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154,SC2009

if [[ -e "$Default_VM_Folder/qqX.custom/custom_main_menu" ]]; then

  #  CAUTION  creating a custom main menu may put you out-of-sync with any qqX updates
  #  Changes here are different to VM selector styles which don't change the underlying code
  source "$Default_VM_Folder/qqX.custom/custom_main_menu"

else

  function main_menu_interface {

    # Default to off as can cause confusion when running certain distro installers as to which drive is being used.
    if [[ $LiveBoot ]] && [[ ! $SharedDrive_Mount ]]; then
      SharedDrive_Conf="no-shared"
      set_drive_paths
    fi

    if [[ ! $ShowUtilsMenu ]]; then

      printf  "\n\n"
      if [[ ! $VM_InstanceName ]]; then printColor  "  [vm]  reselect " ; else   printf  "  [vm]  SELECT "
      fi
      printf  "  [u] show UTILS & technical"
      printf "   [bm] > "
      if [[ $BootStyle == "fast" ]]; then
        printf " fastboot"
        if [[ $Mounted_ISO ]]; then printf "  (toggle to enable boot management menu)"
        else printf "  (toggle)"
        fi
      else
        printColor " boot menu enabled"
        printf "  (toggle)"
      fi

      if [[ $LiveBoot ]] && [[ ! $LiveBootMissing ]]; then
        if [[ "${VM_InstanceName,,}" == *windows* ]]; then
          check_screen_percentage_and_output
          printf "\n\n\n"
          [[ $WebBrowser ]] && printColor "  [qW]"
          printColor "  From qqX 1.14 onwards, ALL the Windows drivers should be autodetected and should autoinstall"
          printf "\n\n  An overview guide is available at https://qqxproject.org/Guides/Windows-OS if needed"
          [[ ! $(type -p swtpm) ]] && printf "\n\n  MAKE SURE to have followed the 'swtpm' setup  <<< IMPORTANT"
          [[ ! $(type -p socat) ]] && printf "\n\n  Missing 'socat' >>> MAKE SURE to have followed the dependency setups  <<< IMPORTANT"
          printf "\n"
          CpuFlags="$(lscpu | grep Flags | tr ' ' '\n')"
          if ! grep -q -e ^'popcnt' <<< "$CpuFlags" || ! grep -q -e ^'sse4_2' <<< "$CpuFlags" ; then
            printColor "\n\n  WARNING: this CPU is unable to support current versions of Windows."
            printf "\n\n  As 'lscpu' reports 'sse4_2' and/or 'popcnt' are not present,"
            printf "\n  the installation is unlikely to be successful, or to be reliable. \n\n"
          fi
        elif [[ "${VM_InstanceName,,}" == *archlinux* ]]; then
          printColor "\n\n  After booting, type 'archinstall' at the command prompt for easier installation ..."
          printColor "\n\n  See https://github.com/archlinux/archinstall for more details"
        fi
        if [[ $(type -p lsblk) ]] && [[ $boot != "legacy" ]] && [[ "$VM_InstanceName" != *windows* ]] \
        &&	[[ "$VM_InstanceName" != *macos* ]] && grep -qs 'btrfs' <<< "$(lsblk -f -o FSTYPE)"; then
          printf "\n\n\n  BTRFS detected: Installing VM's as btrfs, on top of btrfs hosts, can cause slowdown issues"
          printf "\n\n  [cc] mitigation fixes may be possible using a qqX custom booting .... "
          printf "\n\n  See https://www.qemu.org/docs/master/system/images.html#cmdoption-qcow2-arg-nocow"
          printf "\n"
        fi
        if [[ "$VM_InstanceName" == *batocera* ]]; then
          printf "\n\n  Use qqX .conf editor to set up game controllers as ps2 (?) etc."
          printf "\n"
        fi
      elif [[ $LiveBoot ]] && [[ $LiveBootMissing ]]; then
        printColor "\n\n\n  Live BOOT ISO NOT FOUND"
        [[ $FileManager ]] && printf "\n\n  Use [f] to open the VM folder in the system file manager"
        printf "\n"
      elif [[ "${VM_InstanceName,,}" == *windows* ]] && [[ "$Mounted_ISO" == *virtio* ]]; then
        printColor "\n\n\n  Set up ISO's: When everything is working and booting correctly,"
        # main menu routines will nullify any .conf 'fixed_iso' links to non-existent images
        printColor "\n\n  the 'unattended' folder, the 'virtio' and 'unattended' ISO's may be safely removed."
        printColor "\n\n  The Windows ISO is unlikely to be needed so may be archived."
        printf "\n\n  For re-installation, remove only the 'disk.qcow2' drive ..."
        [[ $FileManager ]] && printf "\n\n  Use [f] to open the VM folder in the system file manager"
        printf "\n"
      fi

    else
      printColor "\n  ----------------------------------------------------------------------------"
      printf "\n\n  File Manager: '%s'  Text Editor: '%s'  Browser: '%s' " "$FileManager" "$TextEditor" "$WebBrowser"

      printf "\n\n  [del] delete selected VM   [mv] move, rename or link"
      printColor  "    [u] hide utils & technical"

      printf "\n\n  [2c]  create [2d] delete a second virtual hard-drive   [3c] create [3m] "
      if [[ $SharedDriveArgs ]]; then printf "unmount"; else printf "mount"
      fi
      printf " shared drive (guest boot)"

      printColor "\n\n  ----------------------------------------------------------------------------"
      if [[ $Mounted_ISO ]]; then
        printf "\n\n  [iso] unmount iso from guest, boot from main drive"
      else
        [[ ${#IsoList[*]} -gt 1 ]] && printf "\n\n  [iso] mount iso to guest, allow boot or read from iso"
      fi
      if [[ $BootStyle == "fast" ]]; then printf "   [bm] enable boot management menu"
      else printf "   [fb] use fast boot menu "
      fi
      printf  "\n\n  [tune] config tune-up wizard   [disk]  resize or repair existing drives   [rtv] reset Tiano VMF Vars"

      printColor "\n\n  ----------------------------------------------------------------------------"
      printf "\n\n  [FS] Switch to FreeSpirit  [FB] FreeBird  [HB]  [Cust]  [Dev] "
      printf "\n\n  [hdw] add current config to this VM's Virtual Hardware Record "

      [[ -e "$HOME/.qqX/qqX_term.conf" ]] && printf "\n\n   [tmc] terminal config"

      printColor "\n\n  ----------------------------------------------------------------------------"
      if [[ -e "$QemuArgsCustomFile" ]]; then printf "\n\n  [cd]  delete the custom boot file "
      else printf "\n\n  [cc]  create a custom boot file "
      fi
      if [[ $VerboseArgs ]]; then printf  "  [v] hide verbose boot"
      else  printf  "  [v] show verbose boot args"
      fi
      printf  "   [xa]  view or edit extra qemu args  "

      [[ $ExtraArgs ]] && printf  "\n\n  Extra Args:  %s"  "$ExtraArgs"

      printColor "\n\n  ---------------------------------------------------------------------------- "

    fi

    [[ $MainDrive ]] && SnapCountMain="$("$QEMU_IMG" snapshot -l "$MainDrive" | grep -c '[0-9][0-9]:')"
    [[ $SharedDrive ]] && SnapCountShared="$("$QEMU_IMG" snapshot -l "$SharedDrive" | grep -c '[0-9][0-9]:')"
    [[ $SecondDrive ]] && SnapCountSecond="$("$QEMU_IMG" snapshot -l "$SecondDrive" | grep -c '[0-9][0-9]:')"

    printColor  "\n\n  [sc]  create   [sd]  delete   [sa]  apply   [sl]  list   >  SNAPSHOTS"
    if [[ $SnapCountMain -gt 15 ]]; then  printColor "   main (%s)" "$SnapCountMain"
    else [[ $MainDrive ]] && printf "   main (%s)" "$SnapCountMain"
    fi
    if [[ $SharedDrive ]]; then
      if [[ $SnapCountShared -gt 15 ]]; then printColor "  shared (%s)" "$SnapCountShared"
      else printf "  shared (%s)" "$SnapCountShared"
      fi
    fi
    if [[ $SecondDrive ]]; then
      if [[ $SnapCountSecond -gt 15 ]]; then printColor "  second (%s)" "$SnapCountSecond"
      else printf "  second (%s)" "$SnapCountSecond"
      fi
    fi

    find_kvm_msr_default_and_status
    print_kvm_status_warnings
    [[ $Verbose_MSR_dialog ]] && Verbose_MSR_dialog=

    if [[ ! $ShowUtilsMenu ]]; then

      if [[ -e "$QemuArgsCustomFile" ]]; then
        #QEMU_Default_SystemType= #QEMU_Default_MachineType=  in the general settings file BUT if not present then = 'qemu-system-x86_64'
        MenuCustomSystem="$(grep 'qemu-system' "$QemuArgsCustomFile" | grep -v '#' )"
        MenuCustomMachine="$(grep -m 1 -e '-machine' "$QemuArgsCustomFile" | grep -v '#' | cut -d ',' -f 1)"
        MenuCustomSystemBaseName="$(basename "$MenuCustomSystem")"
        MenuCustomSystemBaseName="$(tr -cd '[:graph:]' <<<"$MenuCustomSystemBaseName")"
        if [[ $QEMU_Default_SystemType == "$MenuCustomSystemBaseName" ]]; then ShowDefault_Hybrid=1 ; else ShowDefault_Hybrid= ; fi
        if [[ $ShowDefault_Hybrid ]] ; then ShowCustomBootStyle= ; else ShowCustomBootStyle=1 ; fi
        [[ $ForceCustomBootStyle == "hide" ]] && ShowCustomBootStyle=  && ShowDefault_Hybrid=1
        [[ $ForceCustomBootStyle == "show" ]] && ShowCustomBootStyle=1 && ShowDefault_Hybrid=
        [[ $PreferHybridCustomMenus ]] && [[ ! $ForceCustomBootStyle ]] && ShowDefault_Hybrid=1 && ShowCustomBootStyle=
      else
        #[[ $ShowCustomBootStyle || $ShowDefault_Hybrid ]] &&  printColor "\n\n  Warning:  Custom boot file removed or name has changed?  Re/Select [vm] to refresh \n"
        if [[ $ShowCustomBootStyle || $ShowDefault_Hybrid ]]; then
          SettingsFileAdjusted=1
          refresh_sources_and_load_VM_arrays
        fi
      fi

      if [[ $ShowCustomBootStyle ]] ; then
        # NB:  "$QemuArgsCustomFile" may exist BUT [c] $UseCustomBootArgs remains menu selectable
        printColor "\n\n  [c]  start VM using custom args with %s %s" "$MenuCustomSystem" "$MenuCustomMachine"
        printf "\n\n  [C]  toggle normal/custom menu  or  use normal:  [d] or [df] > sdl   [s] or [sf] > spice   [g] std gtk "
        printf "\n\n  [ce] edit custom args file    [qd] open Qemu docs in browser"
      elif [[ $LiveBoot && $LiveBootMissing ]]; then
        printColor "\n\n   Hopefully, just a few a tweaks:  "
        if [[ $img || $iso ]]; then  printColor "%s  %s ??" "$img" "$iso"
        else printColor "No Image or ISO listed ??"
        fi
      else
        if [[ $ShowDefault_Hybrid ]]; then
          printColor "\n\n  [c]   start VM with custom args"
          printf "   [ce] edit custom args   [C] toggle normal/custom menu   [qd] browse Qemu docs"
        fi
        printColor  "\n\n  [d]   start with SDL display"
        if [[ $guest_os == "windows" ]]; then  printColor "   (size as set by qqX and/or by Windows)"
        elif [[ $guest_os == "macos" ]] && [[ ! $QE_495_Script ]] && [[ ! $QE_496_Script ]]; then  printColor " (size determined by MacOS with this QE version)"
        elif [[ $SDL_ScreenSize_Error ]]; then printf " (%s%% %s > see settings)"  "$SDL_ScreenPercent"  "$SDL_ScreenSize_Error"
        elif [[ $SDL_ScreenPercent ]]; then printColor " %-12s    [df]  97%% "  "($SDL_ScreenPercent%)"
        elif [[ $guest_os == "macos" || $guest_os == "windows" ]]; then printColor " (%s) "  "$SDL_ScreenSize"
        else printColor " %-11s     [df]  97%% "  "($SDL_ScreenSize)"
        fi
        [[ ! $SDL_ScreenSize_Error ]] && printColor "  (ctrl-alt-f full screen toggle)"
        printf "\n"

        if [[ $HeadlessDisplay ]]; then printColor 	"\n\n  [s]   start with Spice display (HEADLESS) "
        else  printf 	"\n\n  [s]   start with Spice display (scaleable)   [sf]  spice full screen (shift F12 to exit)"  ; fi
        printf "\n\n  [g]   start with GTK display                 "

        if [[ $gl ]] && [[ $Toggled_GL_Mode == "on" ]]; then printf "[gl] is "; printColor "ON"; printf " > toggle I/O on/off"
        elif [[ $gl ]] && [[ $Toggled_GL_Mode == "off" ]] ; then printf "[gl] is "; printColor "OFF"; printf " > toggle I/O on/off"
        elif [[ ! $gl ]] && [[ $Toggled_GL_Mode == "off" ]]; then printf "[gl] is "; printColor "OFF"; printf " > toggle I/O on/off"
        elif [[ $gl == "off" ]]; then printf "[gl] is OFF > toggle I/O on/off"
        else printf "[gl] is ON > toggle I/O on/off"
        fi
        printf " "
        if [[ $network == "restrict" ]] && [[ $qqX_NetMode == "on" ]]; then printf "  [net] is "; printf "ON"; printf " > toggle I/O on/off"
        elif [[ $network == "restrict" || $qqX_NetMode == "restrict" ]]; then printf "  [net] is "; printColor "RESTRICTED"; printf " > toggle I/O on/off"
        elif [[ $qqX_NetMode == "on" ]] ; then printf "  [net] is ON > toggle I/O on/off"
        else printf "  [net] is %s > toggle I/O on/off" "${qqX_NetMode^^}"
        fi

      fi

      printf "\n"

    fi

    [[ $DriveLocationError ]] &&  printColor "\n\n  %s"  "$DriveLocationError"

    if [[ $ConfSettingsAdjusted || $SettingsFileAdjusted ]]; then
      if [[ $SelectArrayError ]]; then printColor "\n\n  Settings Error = %s"  "$SelectArrayError" ; SelectArrayError=
      elif [[ $DefaultFolderError ]]; then printColor "\n\n  Settings Error = Default Folder NOT found" ; DefaultFolderError=
      elif [[ $ExtraFolderError ]]; then printColor "\n\n  Settings Error = %s  NOT found"  "$ExtraFolderError" ; ExtraFolderError=
      elif [[ ! $FileManager_Run  ]]; then
        [[ $ConfSettingsAdjusted ]] &&  printf "\n\n  .conf Settings have been refreshed and reloaded ...."
        [[ $SettingsFileAdjusted ]] &&  printf "\n\n  General Settings have been refreshed and reloaded ...."
      fi
      ConfSettingsAdjusted=
      SettingsFileAdjusted=
      FileManager_Run=
    fi

    if [[ -f "$VM_InstanceName/rtv.date.txt" ]]; then
      SyncDateNow="$(date +%s)"
      SyncDateOld="$(cat "$VM_InstanceName/rtv.date.txt" 2>/dev/null)"
      LastRtvUpd="$((SyncDateNow - SyncDateOld))"
      if [[ $RtvManualOnly ]]; then
        if [[ "$VM_InstanceName" == *macos* ]]; then
          [[ ! $RtvMacosRmdOff ]] && [[ $LastRtvUpd -gt 2592000 ]] && printColor "\n\n  [rtv]  run Tiano update - last run %d days ago"  "$((LastRtvUpd/86400))"
        elif [[ ! $RtvStdRmdOff ]] && [[ $LastRtvUpd -gt 10368000 ]]; then
          printColor "\n\n  [rtv]  run Tiano update - last run %d days ago"  "$((LastRtvUpd/86400))"
        fi
        #  Reminders @ older than 120 days std vars or 30 for mac as has binaries (in epoch seconds)
        #  Auto-updates: do all at 30 days.  Status message for std vars probably OTT, not needed (?)   REVIEW
      elif [[ $LastRtvUpd -gt 2592000 ]]; then
         if [[ "$VM_InstanceName" == *macos* ]]; then
          printf "\n\n  Tiano Core Security Updates .....  "
          refresh_tiano_vars &
          wait "$!"
          RtvMacGet="$(cat "$VM_Conf_Dir/$VM_InstanceName/rtv.status.log" 2>/dev/null)"
          [[ $RtvMacGet == "Okay" ]] && printf "All Good"
          [[ $RtvMacGet == "Fail" ]] && printColor "\n\n  Failed to update. See rtv logs in the VM folder ...."
        else  refresh_tiano_vars &
        fi
      fi
    else  date +%s > "$VM_Conf_Dir/$VM_InstanceName/rtv.date.txt"  2>/dev/null
    fi

    main_loop_diagnostics

    if [[ "$VM_InstanceName" == *macos* && "$VM_InstanceName" == *sonoma* ]]; then
     if ! grep -q -s 'ventura|sonoma' "$QE_SourcePath" ; then printColor "\n\n  Warning: This version of QuickEmu will not run MacOS Sonoma ..." ; fi
    fi

    # use du with -L on instance menus as are individual totals only and some instances can be symbolically linked

    InstanceQcow2_Sizes="$(du -a -L -t 30M "$VM_InstanceName" | grep qcow2 | awk '{print $1}' 2>/dev/null)"

    if [[ $InstanceQcow2_Sizes ]]; then
      InstanceQcow2_SizesCount="$(grep -Ec ^'[1-9]' <<< "$InstanceQcow2_Sizes" 2>/dev/null)"
      InstanceQcow2_Sizes="$(paste -sd+  <<< "$InstanceQcow2_Sizes" | bc -l  2>/dev/null)"
      InstanceQcow2_Sizes="$(bc <<< "scale=1; $InstanceQcow2_Sizes/1000000")"
    else
      InstanceQcow2_Sizes="0"
      InstanceQcow2_SizesCount="0"
    fi

    InstanceISO_Sizes="$(du -a -L -t 30M "$VM_InstanceName" | grep -e 'iso' -e 'img' | awk '{print $1}' 2>/dev/null)"

    if [[ $InstanceISO_Sizes ]]; then
      InstanceISO_SizesCount="$(grep -Ec ^'[1-9]' <<< "$InstanceISO_Sizes" 2>/dev/null)"
      InstanceISO_Sizes="$(paste -sd+  <<< "$InstanceISO_Sizes" | bc -l  2>/dev/null)"
      InstanceISO_Sizes="$(bc <<< "scale=2; $InstanceISO_Sizes/1000000")"
    else
      InstanceISO_Sizes="0"
      InstanceISO_SizesCount="0"
    fi

    printf  "\n\n  [gt]  quickget a new distro   [i] VM drives info   "
    printf "Disks: %s (%s)  "  "${InstanceQcow2_Sizes}G" "$InstanceQcow2_SizesCount"
    printf "ISO's: %s (%s)  "  "${InstanceISO_Sizes}G" "$InstanceISO_SizesCount"
    [[ $(ls "$VM_InstanceName"/*.OLD.qcow2 2>/dev/null) ]] && printColor "(backup disk present)"

    printf  "\n\n"

    filter_and_flag_qemu_errors

    if [[ $QemuErrorAlert ]]; then
      printColor "  [ql]  show qemu error log"
    elif [[ $FileManager ]]; then
      if [[ $(type -p "$FileManager") ]]; then
        printf "  [qf] | [qqf]  open a qcow2 drive"
        printf " in file manager"
        [[ ${#IsoList[*]} -gt 1 ]] && printf "  [iso] un/mount iso to guest"
        if [[ $LiveBootMissing ]]; then  printColor "   [f]  open VM folder"
        else printf "   [f]  open VM folder"
        fi
      else  printColor "  [set]  ERROR file manager not found"
      fi
    fi

    if [[ "$VM_InstanceName" == *'daily'* || "$VM_InstanceName" == "ubuntustudio-dvd" ]] && [[ $(ls "$VM_InstanceName/"*devel.iso 2>/dev/null) ]]; then
      # @ feb 2025 note that 'ubuntustudio-dvd' is now in the standard cdimages repo and has no dvd suffix  REVIEW
      # record d/l data for daily-live alerts

      LastZsync=
      Curr_Zsync_SHA=
      New_Zsync_SHA=
      if [[ $(cat "$VM_InstanceName/dl-url.txt" 2>/dev/null) ]]; then
        Zsync_URL="$(awk '/http/{print $2}' "$VM_InstanceName/dl-url.txt")"
        Zsync_SHA_URL="$(dirname "$Zsync_URL")""/SHA256SUMS"
        New_Zsync_SHA="$(curl -sf --max-time 3 "$Zsync_SHA_URL" | grep -s amd64 | cut -d' ' -f1 &)"
      fi

      #  Live VMs where zsync updates the iso file.
      if [[ "$(tr -cd '[:digit:]' 2>/dev/null < "$VM_InstanceName/zsync.date.txt")" ]]; then
        SyncDateNow="$(date +%s)"
        SyncDateOld="$(tr -cd '[:digit:]' 2>/dev/null < "$VM_InstanceName/zsync.date.txt")"
        LastZsync="$((SyncDateNow - SyncDateOld))"
        printf "\n\n"
        if [[ $LastZsync -gt 259200 ]]; then  printf "  [z]   daily-live - last zsync over %d hrs ago"  "$((LastZsync/3600))"
        else  printf "  [z]   daily-live - last zsync %d hrs ago"  "$((LastZsync/3600))"
        fi  #  older than 3 days (in epoch seconds)  REVIEW
        if [[ $LastZsync -gt 864000 ]]; then printColor "  (out-of-date)"  # 10 days  (NB: esp. important at change of url naming at xx.04 etc)
        elif [[ $New_Zsync_SHA ]] && [[ $(cat "$VM_InstanceName/dl-sha.txt") ]]; then
          Curr_Zsync_SHA="$(awk '{print $1}' "$VM_InstanceName/dl-sha.txt")"
          if [[ ${Curr_Zsync_SHA// /} == "${New_Zsync_SHA// /}"  ]]; then printf "  (up-to-date)"; else printColor "  (update available)"
          fi
        else
          # if check is not yet available
          printf "  (refresh to check)"
        fi
      else  date +%s > "$VM_InstanceName/zsync.date.txt"
      fi

      ##  ZSYNC   See  functions 'get_ubuntu' & 'list_csv' in quickget

        # qqX: NB: only the iso gets dubbed with 'devel' suffix, otherwise VMs they keep their names
        # eg  'ubuntu-mate-daily-live' 'ubuntustudio-dvd' 'ubuntu-daily-canary'
        # An actual 'ubuntu-devel' release or folder doesn't seem to ever get created or offered.
        # Presume release=devel (@2023/07) has now been superseded, or was merely intended as an indicative name only ...
        # Also note that quickget includes code to remove 'zs.old' files, which may or may not have been needed,
        # but Zsync can now give these files root protection so this removal may not work ...   REVIEW  Add a qqX copying mechanism?

      # Sort out the quickget / function_quick_get_wrap  call & the var/flags
      # Expect these to need updating from time to time ...

      # @ feb 2025 improve for ubuntu variants, for daily-live, and for renamed instances

      if [[ $(cat "$VM_InstanceName/dl-url.txt" 2>/dev/null) ]]; then
        Zsync_RecordedName="$(awk '/http/{print $1}' "$VM_InstanceName/dl-url.txt")"
      elif [[ $(cat "$VM_InstanceName/QemuVirtHardwareRecord.txt" 2>/dev/null) ]]; then
        Zsync_RecordedName="$(grep -sm1 -e '-name' "$VM_InstanceName/QemuVirtHardwareRecord.txt" | cut -d'=' -f2)"
      else Zsync_RecordedName="$VM_InstanceName"
      fi
      Zsync_OS_Name="${Zsync_RecordedName,,}"
      Zsync_OS_Name="${Zsync_OS_Name/'-daily'/}"
      Zsync_OS_Name="${Zsync_OS_Name/'-live'/}"
      Zsync_OS_Name="${Zsync_OS_Name/'-canary'/}"
      Zsync_OS_Name="${Zsync_OS_Name/'-legacy'/}"
      Zsync_OS_Name="${Zsync_OS_Name/'-jammy'/}"
      Zsync_OS_Name="${Zsync_OS_Name/'-dvd'/}"
      Zsync_Release_Name="${Zsync_RecordedName,,}"
      Zsync_Release_Name="${Zsync_Release_Name/"${Zsync_OS_Name}-"/}"
      Zsync_Updatable_ISO=1
      # zero main menu flag that sets only if updater run from main
      MainMenuZsync=

    else

      Zsync_Updatable_ISO=
      Zsync_OS_Name=
      Zsync_Release_Name=

    fi

    if [[ $ShowTxTexts ]]; then printColor  "\n\n  [tx] %s" "$MainTxOptionLine"
    else printf  "\n\n  [tx] %s" "$MainTxOptionLine"
    fi
    printf "   [set] open settings file in text editor  "
    if [[ $LiveBootMissing ]]; then printColor "[conf] view or edit .conf file"
    else  printf "[conf] view or edit .conf file"
    fi
    printf  "\n\n"

    read_update_check_file
    check_beta_alert_count
    check_disk_is_okay
    check_if_disk_needs_a_cleanup

    if [[ $DiskChkStatus ]] && [[ $DiskChkStatus != "Okay" ]]; then
      printColor "  DISK.QCOW2 ERROR  %s  \n\n  [disk] repair utils "  "$DiskChkStatus"
    elif [[ $DiskDisparity -ge "4" ]]; then  printColor "  DISK.QCOW2 could benefit from a clean up  > [disk] repair utils \n\n"
    elif [[ $DiskDisparity -ge "3" ]]; then  printColor "  DISK.QCOW2 may need a clean up  > [disk] repair utils \n\n"
    elif [[ $DiskDisparity -ge "2" ]]; then  printf "  DISK.QCOW2 may need a clean up  > [disk] repair utils \n\n"
    elif [[ $Muted_BetaAlertPoint ]] && [[ ! $Hide_qqX_BetaUpdates ]]; then
      # beta release on the 'latest' channel takes priority over pre-releases
      # caution \n\n differs on 'array select script'
      if [[ $qqX_Latest_ReleaseNumber ]] && floatversion -Q --gt "$qqX_Latest_ReleaseNumber  $qqX_Version" ; then
        printColor "  [dl]  view new qqX update details: %s\n\n" "$qqX_Latest_ReleaseNumber"
      elif [[ $qqX_Newest_PreRelease ]]; then printf "  [dl]  view new qqX update details: %s\n\n" "$qqX_Newest_PreRelease"
      fi
    elif [[ $qqX_UpdateAvail ]]; then printColor "  [dl]  view new qqX update details: %s \n\n" "$qqX_Latest_ReleaseNumber"
    fi

    check_conf_file_for_typos "$VM_Conf_Dir/$VM_Conf_File"
    [[ $ConfTypo ]] && printColor "\n\n  ERROR(s) detected in the Config file ...\n\n"

    if ps -ef | grep nbd | grep -qi "$VM_InstanceName" ; then
      printf "\n\n  A mount conflict may exist ...  NBD drives may be viewed but must be disconnected before starting the VM \n\n"
    fi

    ## Resolve the original distro OS name so a quickget look up can be made:
    # qget 4.9.2 onwards - use recorded name as VM can get renamed
    if [[ $(cat "$VM_InstanceName/qe_new_vm_name.txt" 2>/dev/null) ]]; then
      source "$VM_InstanceName/qe_new_vm_name.txt"
      VM_RecordedName="$New_VM_InstanceName"
    elif [[ $(cat "$VM_InstanceName/QemuVirtHardwareRecord.txt" 2>/dev/null) ]]; then
      VM_RecordedName="$(grep -sm1 -e '-name' "$VM_InstanceName/QemuVirtHardwareRecord.txt" | cut -d'=' -f2)"
    else  VM_RecordedName="$VM_InstanceName"
    fi
    VM_RecordedName="${VM_RecordedName,,}"
    mapfile -t VM_RecordedNameArr <<< "$(tr '-' '\n' <<< "$VM_RecordedName")"
    # note grep with space or probs like ubuntu picks (ed)ubuntu first
    # needs to cope with ubuntu variants, for daily-live, for renamed instances, and for custom ISO installed
    # and for qMod avoid script start, as that de-listed distros and other bits
    if [[ $QG_Modpath ]] && grep -qs "  ${VM_RecordedNameArr[0]}-${VM_RecordedNameArr[1]})" <<< "$(grep -s -A 500 -m 1 'INFO=' "$QG_Modpath")" ; then
      VM_RecordedName_Listed="${VM_RecordedNameArr[0]}-${VM_RecordedNameArr[1]}"
    elif [[ $QG_Modpath ]] && grep -qs "  ${VM_RecordedNameArr[0]})" <<< "$(grep -s -A 500 -m 1 'INFO=' "$QG_Modpath")" ; then
      VM_RecordedName_Listed="${VM_RecordedNameArr[0]}"
    elif grep -qs "  ${VM_RecordedNameArr[0]}-${VM_RecordedNameArr[1]})" "$QG_SourcePath" ; then
      VM_RecordedName_Listed="${VM_RecordedNameArr[0]}-${VM_RecordedNameArr[1]}"
    elif grep -qs "  ${VM_RecordedNameArr[0]})" "$QG_SourcePath" ; then
      VM_RecordedName_Listed="${VM_RecordedNameArr[0]}"
    else VM_RecordedName_Listed=
    fi

    ## Find Distro HomePage URL
    DistroHomePage= ; DistroInfoLine= ; DistroListing= ; DistroLogin=
    if [[ $VM_RecordedName_Listed ]]; then
      [[ $QG_Modpath ]] && DistroInfoLine="$(grep -s 'INFO=' "$QG_Modpath" | grep -m 1 "  ${VM_RecordedName_Listed})" )"
      [[ ! $DistroInfoLine ]] && DistroInfoLine="$(grep -s 'INFO=' "$QG_SourcePath" | grep -m 1 "  ${VM_RecordedName_Listed})" )"
      if [[ $DistroInfoLine ]]; then
        DistroListing="$(cut -d'=' -f2 <<< "$DistroInfoLine")"
        DistroListing="${DistroListing//';;'/}"
        DistroListing="${DistroListing//'"'/}"
        DistroListing="$(tr '|' '\n' <<< "$DistroListing")"
        mapfile -t DistroListing_ARR <<< "$DistroListing"
        DistroHomePage="${DistroListing_ARR[2]}"
        DistroLogin="${DistroListing_ARR[1]}"
        [[ $DistroLogin == "-" ]] && DistroLogin=
      fi
    fi

    printColor  "  [enter] refresh   "
    if [[ $DistroHomePage ]]; then printColor "[w] distro homepage  "
    else printf "(no distro webpage listed)  "
    fi
    printf " [h] show help & info  [b] go back  [q] quit "

    if [[ $LiveBoot && $DistroLogin ]]; then
      printColor "\n\n  Login:Password"
      printf "  %s" "$DistroLogin"
    fi
    printf "\n\n"

    path_diagnostics

    if [[ $MainMenuChoicePreset ]]; then
      printf "  >  %s \n" "$MainMenuChoicePreset"
      MainMenuChoice="$MainMenuChoicePreset"
      MainMenuChoicePreset=
    fi
    [[ ! $MainMenuChoice ]] &&  read -rp "  >  "  MainMenuChoice

  }

fi
