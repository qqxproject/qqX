#!/usr/bin/env bash

##  qqX component to be located in folder 'qqX.main'

##  Copyright (c)  Alex Genovese   https://github.com/qqxproject
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.

# 	Otherwise:

# Licence  GPL3   https://www.gnu.org/licenses

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# https://www.gnu.org/licenses


# IF CODE IN GENERAL BECOMES USED IN ANY OTHER PROJECT,
# THE GPL3 LICENCE APPLIES & YOU SHOULD SHOW CLEAR ATTRIBUTIONS.


##  qqX - quickemu quickget X terminal project

#  This script is based on ffX - the ff(mpeg) X-terminal project - AV processing scripts for ffmpeg
#  Also copyright (c)  Alex Genovese   https://github.com/qqxproject   https://github.com/ffxproject

#  Updated 2024/04 to work with changes to fedora 40 and github

#  Make sure shell is set during session to decimal separator of dot
#  If LC_ALL=C changes too much, just set the numeric.
#  This may upset some input/output filters ....    CAUTION   (see notes in the main settings)

#  See locale setting discussion:  https://unix.stackexchange.com/a/149129
#  Also  https://unix.stackexchange.com/questions/62316/why-is-there-no-euro-english-locale?rq=1
#  &   http://www.unicode.org/L2/L2001/01102-POSIX15897.htm


## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154

## Foreground internet test that can be called as needed  (see function_quick_get_wrap)
# Also forced internet check/re-check when starting 'gt' menu (see $VM_Selection == "gt")

test_internet_is_up () {
  # Produces general foreground Flag 'InternetUp' plus 'ipOkay' and 'DnsOkay' for granular reportage (see function_quick_get_wrap)
  # Note that 'ping' doesn't work inside a Qemu VM, so prefer wget as second test,
  # as there are no changes to '--spider' in wget2  https://gitlab.com/gnuwget/wget2/-/wikis/home
  local ShowProcess=1 ; [[ $1 == "quiet" ]] && ShowProcess=
  [[ $ShowProcess ]] && { printf  "\n  Checking connections ...  \n" ; sleep 0.5; }
  if   curl --disable -sLf -I -o /dev/null --retry 2 --max-time 3 --no-keepalive  "1.1.1.1"  2> /dev/null ; then ipOkay=1
  elif   curl --disable -sLf -I -o /dev/null --retry 2 --max-time 3 --no-keepalive  "8.8.8.8"  2> /dev/null ; then ipOkay=1
  elif wget -q -T2  -t2 --spider 1.1.1.1  2> /dev/null ; then ipOkay=1
  else ipOkay=
  fi
  if [[ $ipOkay ]]; then
    [[ $ShowProcess ]] && { printf  "\n  Checking DNS ...  \n" ; sleep 0.5; }
    if curl --disable -sLf -I -o /dev/null --retry 2 --max-time 3 --no-keepalive  "cloudflare.com"  2> /dev/null ; then DnsOkay=1
    elif curl --disable -sLf -I -o /dev/null --retry 2 --max-time 3 --no-keepalive  "google.com"  2> /dev/null ; then DnsOkay=1
    elif wget -q -T2 -t2 --spider google.com 2> /dev/null ; then DnsOkay=1
    else DnsOkay=
    fi
  fi
  if [[ $ipOkay && $DnsOkay ]]; then InternetUp=1 ; else InternetUp=
  fi
}

################################################################

# The function 'check_for_qqX_updates' runs once only, at qqX start-up in the background,
# and a TRANSFER FILE is used to move the variables to the foreground
# These foreground vars get declared and cleared here, on first sourcing of the file,
# before the function is run AND do NOT clear the files on any sys refresh:

if [[ ! $qqX_SelfChk_Run ]]; then
  qqX_Latest_ReleaseNumber=
  qqX_Latest_ReleaseType=
  qqX_Latest_SecureTarBall_Addr=
  qqX_Latest_SecureTarSha_Addr=
  qqX_Newest_PreRelease=
  qqX_Newest_Tag=
  qqX_UpdateAvail=
  qqX_Upd_VarsTmpFile="/tmp/qqX.upd.chk.txt"
  printf "\n\n qqX_UpdateAvail="  > "$qqX_Upd_VarsTmpFile"
  qqX_Latest_ReleaseFile="/tmp/latest-qqX"
  qqX_Latest_PreReleaseFile="/tmp/latest-pre-release-qqX"
  [[ -e $qqX_Latest_ReleaseFile ]] && rm "$qqX_Latest_ReleaseFile" 2>/dev/null
  [[ -e $qqX_Latest_PreReleaseFile ]] && rm "$qqX_Latest_PreReleaseFile" 2>/dev/null
  qqX_SelfChk_Run=1
fi

################################################################

check_for_qqX_updates() {

  # Quietly do a check for new releases and return required vars if update available
  # Using 'fv --full' detects 'beta' releases, alpha, rc etc AND to be NORMALLY 'pre-releases' only

  # FIRST PAGE, includes 'latest' and 'pre-releases' (newest)
  qqX_ReleasesList="$(curl -qsLf  -m 180 "https://github.com/qqxproject/qqX/releases" | tr ' ' '\n' | grep -s tree | fv --full -Q)"
  [[ ! $qqX_ReleasesList ]] && return 1

  qqX_Latest_ReleaseNumber="$(fv -Q -M <<< "$qqX_ReleasesList")"
  [[ ! $qqX_Latest_ReleaseNumber ]] && return 1

  qqX_Newest_PreRelease="$(fv --full -Q -M <<< "$qqX_ReleasesList")"
  [[ $qqX_Newest_PreRelease != *[[:alpha:]]* ]] && qqX_Newest_PreRelease=

  # All tags, released or not:
  qqX_Newest_Tag="$(curl -qsf -qsLf  -m 180  "https://github.com/qqxproject/qqX/tags" | grep -s 's/tag' | fv -M -Q --full)"

  # ..ReleaseFiles contain the tarball addresses and other data
  # but PLAIN curl downloads won't work as the pages are javascript rendered
  # So, use Github's API (no access-token needed, works on any repo) BUT it only works with github's 'latest' routing algo ...
  local ApiTarget=
  ApiTarget="https://api.github.com/repos/qqxproject/qqX/releases/latest"
  curl -qsLf -m 180 -H "X-GitHub-Api-Version:2022-11-28" "$ApiTarget" -o "$qqX_Latest_ReleaseFile"
  sleep 1
  [[ ! -e  "$qqX_Latest_ReleaseFile" ]] && return 1

  # Versioning, normally as x.x.xx-suffix > major.minor.point and with optional suffix as -beta.01 etc
  # where --gt check eg "1.12.02-beta.01  1.12.01" is true (remembering that fv --gt also implies --full)

  if floatversion --gt -Q "$qqX_Latest_ReleaseNumber  $qqX_Version"; then
    qqX_UpdateAvail="$qqX_Latest_ReleaseNumber"
    # Flag up release type > allows a beta release on the standard 'latest' channel, if required
    if [[ $qqX_Latest_ReleaseNumber == *[[:alpha:]]* ]] ; then  qqX_Latest_ReleaseType="beta"
    else qqX_Latest_ReleaseType="release"
    fi
    [[ $qqX_Latest_ReleaseType == "beta" ]] && [[ $Hide_qqX_BetaUpdates ]] && qqX_UpdateAvail=
    if [[ $qqX_UpdateAvail ]]; then
      # make sure that GitHub is listing a tarball download address
      # eg. "https://github.com/qqxproject/qqX/releases/download/$qqX_Latest_ReleaseNumber/qqX-$qqX_Latest_ReleaseNumber.tar.gz"
      if [[ "$(tr '"' '\n' < "${qqX_Latest_ReleaseFile}" | grep -s http | grep -sc '/releases/download/')" == "2" ]] ; then
        qqX_Latest_SecureTarBall_Addr="$(tr '"' '\n' < "${qqX_Latest_ReleaseFile}" | grep -s http | grep -s -m 1 '/releases/download/')"
        qqX_Latest_SecureTarSha_Addr="${qqX_Latest_SecureTarBall_Addr}.sha256"
      fi
    fi
  elif [[ $qqX_Current_ReleaseType == "beta" ]]; then
    # Then give a flag and easy download to people who are on the pre-release beta channel
    # Although, offering a return to the standard release channel first,
    # for people who have not been using qqX for a bit and haven't had a chance to update maybe ...
    # eg people with 1.14.00-beta.07 get offered 1.14.00 or 1.14.01 before they get offered 1.15.00-beta.10
    if floatversion --gt -Q "$qqX_Newest_PreRelease  $qqX_Version"; then
      qqX_Latest_ReleaseType="beta"
      qqX_Latest_ReleaseNumber="$qqX_Newest_PreRelease"
      qqX_UpdateAvail="$qqX_Newest_PreRelease"
      # make use the presumed standard format and check if correct (given that the API route cannot be used)
      qqX_Latest_SecureTarBall_Addr="https://github.com/qqxproject/qqX/releases/download/${qqX_Newest_PreRelease}/qqX-${qqX_Newest_PreRelease}.tar.gz"
      if [[ "$(curl -qsLf --head  --location-trusted -m 180 "$qqX_Latest_SecureTarBall_Addr" | grep 'HTTP/' | tail -n1)" != *200* ]]; then
        qqX_Latest_SecureTarBall_Addr=
      fi
      qqX_Latest_SecureTarSha_Addr="https://github.com/qqxproject/qqX/releases/download/${qqX_Newest_PreRelease}/qqX-${qqX_Newest_PreRelease}.tar.gz.sha256"
      if [[ "$(curl -qsLf --head  --location-trusted -m 180 "$qqX_Latest_SecureTarSha_Addr" | grep 'HTTP/' | tail -n1)" != *200* ]]; then
        qqX_Latest_SecureTarSha_Addr=
      fi
    fi
  fi

  # Inherits Vars from qqX nesting but IF A NEW UPDATE IS FOUND
  # but needs to populate an OUTPUT TRANSFER FILE, as check runs in background ...  NB:
  { printf "\n\n # %s" "$(date)"
    printf "\n\n qqX_UpdateAvail=\"%s\"" "$qqX_UpdateAvail"

    printf "\n\n qqX_Latest_ReleaseNumber=\"%s\""  "$qqX_Latest_ReleaseNumber"
    printf "\n\n qqX_Latest_ReleaseType=\"%s\""  "$qqX_Latest_ReleaseType"
    printf "\n\n qqX_Latest_SecureTarBall_Addr=\"%s\""  "$qqX_Latest_SecureTarBall_Addr"
    printf "\n\n qqX_Latest_SecureTarSha_Addr=\"%s\""  "$qqX_Latest_SecureTarSha_Addr"

    printf "\n\n qqX_Newest_PreRelease=\"%s\""  "$qqX_Newest_PreRelease"
    printf "\n\n qqX_Newest_Tag=\"%s\""  "$qqX_Newest_Tag"

    printf "\n\n qqX_upd_FileChk=\"%s\""  "done"

  } > "$qqX_Upd_VarsTmpFile"

}

function read_update_check_file {
  if [[ ! $qqX_upd_FileChk ]] && [[ $(cat "$qqX_Upd_VarsTmpFile" 2>/dev/null) ]]; then
    source "$qqX_Upd_VarsTmpFile"
    if [[ ! $Hide_qqX_BetaUpdates ]] && [[ $qqX_Newest_PreRelease ]] && [[ $qqX_Current_ReleaseType == "release" ]] && floatversion --gt -Q "$qqX_Newest_PreRelease  $qqX_Version"; then
      # hide release details as will relate to non-beta unless people are on the beta channel
      Muted_BetaAlertPoint=1
    else Muted_BetaAlertPoint=
    fi
  fi
}

function check_beta_alert_count {
  ((Muted_BetaAlert_Count+=1)) ; ((Muted_BetaAlert_Count >4)) && Hide_qqX_BetaUpdates=1
}

# Runs in the background. qqX will run this once.
function find_latest_qemu_version {
  printf "" > "/tmp/latest-qemu.txt"
  { floatversion --full -M "$(curl --disable -sLf --retry 3 --max-time 8 "https://github.com/qemu/qemu/tags" | grep -s 'Link--primary')" 2>/dev/null; } > "/tmp/latest-qemu.txt"
}

function download_new_release {

    printf "\033c \n\n"
    qqX_logo_printf_title  "$qqX_Version updater"
    printf "\n\n\n  https://github.com/qqxproject/qqX/releases"

    local UpdRechk=
    while true ; do
      if [[ $Muted_BetaAlertPoint ]]; then
        if [[ $UpdRechk == "once" ]]; then UpdRechk="done"
        else printf "\n\n"
        fi
        printColor "  Pre-Release %s .... " "$qqX_Newest_PreRelease"
        printColor "\n\n  See source releases and commits for more details"
        printf "\n\n  Pre-releases are generally stable and will have had some testing."
        printf "\n\n  They offer new features and bug-fixes but may be a little rough on the edges ...."
        printf "\n\n  Using the Beta Channel is on a per release-series basis. It may mean more frequent updates."
        printf "\n\n  Installing a standard release, either older or upcoming, will revert qqX to using standard releases."
        printf "\n\n"
        if floatversion -Q --gt "$qqX_Newest_Tag  $qqX_Newest_PreRelease" ; then
          printf "\n  Further add-on pre-release tweaks can be found at https://github.com/qqxproject/qqX/tags"
          printf "\n\n"
        fi
        # add Avail flag here, so beta alerts are more muted
        qqX_UpdateAvail="$qqX_Newest_PreRelease"
      fi
      if [[ ! $qqX_UpdateAvail ]] ; then
        if [[ $UpdRechk == "once" ]]; then UpdRechk="done"
        else printf "\n\n"
        fi
        printColor "  No new release found ...."
        if [[ $qqX_Current_ReleaseType == "beta" ]] && floatversion -Q --gt "$qqX_Newest_Tag  $qqX_Newest_PreRelease" ; then
          printf "\n\n  Further add-on pre-release tweaks %s can be found at https://github.com/qqxproject/qqX/tags" "$qqX_Newest_Tag"
          UpdRechk="once"
        fi
        printf "\n\n"
      elif [[ ! $Muted_BetaAlertPoint ]]; then
        [[ ! $qqX_Latest_SecureTarBall_Addr ]] && printf "\n\n  Via Non-SHA checked download ...."
        printf "\n\n  %s \n"  "$qqX_Latest_SecureTarBall_Addr"
        # if version can handle new format, otherwise leave notes as blank
        if floatversion -Q --gt "$qqX_Version  1.13.02" && [[ $qqX_Latest_ReleaseNumber != "$qqX_Newest_PreRelease" ]]; then
          AboutWidth="$(tput cols)"
          printf "\n  %s\n" "$qqX_Latest_ReleaseNumber"
          #shellcheck disable=SC1003  # the double \
          mapfile -t AboutReleaseArray <<< "$(grep body  "$qqX_Latest_ReleaseFile" | cut -d'"' -f 4 | cut -d'\' -f2- | tr '\\' '\n' \
          | grep -e ^'n' | cut -d'n' -f2-)"
          for Line in "${AboutReleaseArray[@]}" ; do  if [[ "$Line" != *'+1'* ]] ; then printColor "  %s\n" "$(fmt -uw "$AboutWidth" <<< "$Line")" ; fi ; done
        elif [[ $Muted_BetaAlertPoint ]]; then
          printf "\n\n  %s   >>   %s\n\n"  "$qqX_Version"  "$qqX_Newest_PreRelease"
          qqX_UpdateAvail=
        else
          printf "\n\n  %s   >>   %s\n\n"  "$qqX_Version"  "$qqX_Latest_ReleaseNumber"
        fi
      fi
      printf "\n"
      if [[ $qqX_UpdateAvail ]] && [[ ! $Muted_BetaAlertPoint ]] ; then
        printf "  Neatly download the release into its own sub-folder at: "
        [[ $Specified_Updates_Location ]] && printf "\n\n  [s] Specified folder:  %s"  "$Specified_Updates_Location"
        [[ -d "$HOME/Downloads" ]] && printf "\n\n  [d] Downloads folder:  %s"  "$HOME/Downloads"

        if [[ $(pwd) == "$Default_VM_Folder" ]]; then
          printColor "\n\n  [enter] Current/Default folder:"
          printf "  %s "  "$Default_VM_Folder"
        else
          # not to confuse with '$Current_VM_Folder'
          printf "\n\n  [c] Current folder:    %s "  "$(pwd)"
          printColor "\n\n  [enter] Default VM folder:"
          printf "  %s"  "$Default_VM_Folder"
        fi
        printf "\n\n"
      fi
      printf "  [r] to recheck"
      if [[ $WebBrowser ]]; then
        if [[ $Muted_BetaAlertPoint ]]; then  printf "   [w] popup qqX RELEASE pages with browser"
        else printf "   [w] popup qqX web pages with browser"
        fi
      fi
      printf "  or  [b] to go back \n\n"
      read -rp "  >  "  qqX_LatestTarBall_Folder

     [[ ! $qqX_UpdateAvail ]] && printf "\n\n"

      if [[ $qqX_LatestTarBall_Folder == "s" ]]; then  qqX_LatestTarBall_Folder="$Specified_Updates_Location" ; break
      elif [[ $qqX_LatestTarBall_Folder == "d" ]]; then  qqX_LatestTarBall_Folder="$HOME/Downloads" ; break
      elif [[ $qqX_LatestTarBall_Folder == "c" ]]; then  qqX_LatestTarBall_Folder="$(pwd)" ; break
      elif [[ $qqX_LatestTarBall_Folder == "w" ]]; then
        printf "  Opening Browser ... \n\n"
        if [[ $Muted_BetaAlertPoint ]]; then
          (nohup &> /dev/null  "$WebBrowser"  "https://github.com/qqxproject/qqX/releases/tag/${qqX_Newest_PreRelease}" & ) || web_browser_not_found_message
        else (nohup &> /dev/null  "$WebBrowser"  "https://github.com/qqxproject/qqX" & ) || web_browser_not_found_message
        fi
        sleep 1
      elif [[ $qqX_LatestTarBall_Folder == "b" ]]; then
        qqX_LatestTarBall_Folder= ; qqX_NoReleaseDL=1 ; qqX_UpdateAvail= ; ((Muted_BetaAlert_Count+=1)) ; break
      elif [[ $qqX_LatestTarBall_Folder == "r" ]]; then
        qqX_LatestTarBall_Folder= ; [[ ! $UpdRechk ]] && UpdRechk="once" ; read_update_check_file
      else qqX_LatestTarBall_Folder="$Default_VM_Folder" ; break
      fi
    done

    if [[ $qqX_NoReleaseDL ]]; then  qqX_NoReleaseDL=
    else
      # each release to its own FOLDER makes things tidier
      qqX_LatestTarBall_Folder="$qqX_LatestTarBall_Folder/qqX.releases/$qqX_Latest_ReleaseNumber"
      # make sure each DOWNLOAD is clean
      [[ -d "$qqX_LatestTarBall_Folder" ]] && rm -r "$qqX_LatestTarBall_Folder" 2>/dev/null
      sleep 0.5; mkdir -p "$qqX_LatestTarBall_Folder" ; sleep 0.5
      # record where to come back to, when done and not to confuse with '$Current_VM_Folder'
      ReturnFolder="$(pwd)"
      # MOVE to download folder and keep things contained
      cd "$qqX_LatestTarBall_Folder"  || printColor "\n\n  ERROR  making or changing to qqX.releases folder ??"

      if [[ $(pwd) != "$qqX_LatestTarBall_Folder" ]]; then
        # if we are not in the right folder, we need to exit
        printf "\n\n  [enter] to return \n\n"
        read -rp "  >  "
      else
        if [[ $qqX_Latest_SecureTarBall_Addr ]]; then
          dlCount="1"
          while [[ $dlCount -le "3" ]]; do
            eval curl --disable -Lf -m 20 -o "$qqX_LatestTarBall_Folder/qqX-${qqX_Latest_ReleaseNumber}.tar.gz"  "$qqX_Latest_SecureTarBall_Addr"
            echo
            eval curl --disable -Lf -m 20 -o "$qqX_LatestTarBall_Folder/qqX-${qqX_Latest_ReleaseNumber}.tar.gz.sha256"  "$qqX_Latest_SecureTarSha_Addr"
            echo
            SHA_Check="$(sha256sum -c "$qqX_LatestTarBall_Folder/qqX-${qqX_Latest_ReleaseNumber}.tar.gz.sha256")"
            printColor "\n  SHA256 Check: %s "  "$SHA_Check"
            if [[ "$SHA_Check" != *'OK' ]]; then
              rm -r ./*  2>/dev/null
              printf "\n\n  ERROR  - RETRYING  DOWNLOAD \n\n"
            else printf "\n\n" ; break
            fi
            ((dlCount++))
          done
        fi
        # Drop to non-sha, if assets not available
        if [[ ! -e "qqX-${qqX_Latest_ReleaseNumber}.tar.gz" ]]; then
          rm -r ./*  2>/dev/null
          printf "\n  Problem auto-downloading via Secure Tarball"
          printColor "\n\n  Using standard NON sha256-checked \n\n"
          dlCount="1"
          while [[ $dlCount -le "3" ]]; do
            qqX_Latest_NonSecure_TarBall="https://github.com/qqxproject/qqX/archive/refs/tags/${qqX_Latest_ReleaseNumber}.tar.gz"
            eval curl --disable -Lf -m 20 -o "$qqX_LatestTarBall_Folder/qqX-${qqX_Latest_ReleaseNumber}.tar.gz" "$qqX_Latest_NonSecure_TarBall"
            echo
            if [[ ! -e "qqX-${qqX_Latest_ReleaseNumber}.tar.gz" ]]; then
              rm -r ./*  2>/dev/null
              printf "\n\n  ERROR  - RETRYING  DOWNLOAD \n\n"
            else printf "\n\n" ; break
            fi
            ((dlCount++))
          done
        fi

        if [[ ! -e "qqX-${qqX_Latest_ReleaseNumber}.tar.gz" ]]; then
          printf "  Problem auto-downloading Tarball"
          printColor "\n\n  Download file '%s not found \n\n" "qqX-${qqX_Latest_ReleaseNumber}.tar.gz"
        fi

        printColor "  File download target %s"  "$qqX_LatestTarBall_Folder"

        printf "\n\n  Use the installer script to quickly refresh and add new features to your settings file."
        printf "\n\n  All option settings, locations and preferences will be kept."
        printf "\n\n\n  "
        [[ -e "qqX-${qqX_Latest_ReleaseNumber}.tar.gz" ]] && printf "[enter] to run the installer script   "
        printf "[r] to return to main menu \n\n"
        read -rp "  >  "  qqX_UpdateExit

        if [[ $qqX_UpdateExit != "r" ]] && [[ ! -e "qqX-${qqX_Latest_ReleaseNumber}.tar.gz" ]]; then
          printColor "\n\n  ERROR: Download folder/file not found ??"
          printf "\n\n  [enter] to close and retry \n\n"
          read -rp "  >  "
          qqX_UpdateExit="r"
        else
          # https://stackoverflow.com/questions/651018/opening-a-tar-gz-file-with-a-single-command
          tar xfz "qqX-${qqX_Latest_ReleaseNumber}.tar.gz"
          sleep 0.5
          if [[ -d "qqX-${qqX_Latest_ReleaseNumber}" ]]; then
            # is using fall-back mode
            cp -r "qqX-${qqX_Latest_ReleaseNumber}"/* .
          fi
          sleep 0.5
          if [[ ! -e "qqX_setup_and_install" ]] ; then
            printColor "\n\n  ERROR extracting the download files ??"
            printf "\n\n  [enter] to close and retry \n\n"
            read -rp "  >  "
            qqX_UpdateExit="r"
          fi
        fi
        if [[ $qqX_UpdateExit != "r" ]]; then
          # start the SYSTEM installer (use the posix installer for initial or manual installs)
          exec  bash -c "$qqX_LatestTarBall_Folder/qqX.system/qqX_system_install  Upgrade"
        fi
      fi

      sleep 0.5
      cd "$ReturnFolder"  || printColor "\n\n  ERROR  returning from qqX.releases folder"

    fi
}


