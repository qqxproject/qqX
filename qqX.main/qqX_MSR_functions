#!/usr/bin/env bash

##  qqX component to be located in folder 'qqX.main'

##  Copyright (c)  Alex Genovese   https://github.com/qqxproject
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.
# 	Otherwise:
#   Licence  GPL3   https://www.gnu.org/licenses
##  qqX - quickemu quickget X terminal project

## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154


find_kvm_msr_default_and_status () {

  # Gives values to VARIABLES: 'KVM_MSR_DefaultConf' & 'KVM_MSR_status' as Y or N
  # Finds and flags if MSRS has a config conflict for use by function 'print_kvm_status_warnings' & other

  KVM_MSR_Error= ; KVM_MSR_Warn=

  KVM_MSR_status="$(cat /sys/module/kvm/parameters/ignore_msrs 2>/dev/null)"
  [[ ! $KVM_MSR_ModProbeFile ]] && KVM_MSR_ModProbeFile="/etc/modprobe.d/kvm-quickemu.conf"
  KVM_MSR_DefaultConf="$(cat "$KVM_MSR_ModProbeFile" 2>/dev/null)"

  [[ "$KVM_MSR_DefaultConf" == *'=Y' ]] &&  KVM_MSR_default="Y"
  [[ "$KVM_MSR_DefaultConf" == *'=N' ]] || [[ ! -e "$KVM_MSR_ModProbeFile" ]] &&  KVM_MSR_default="N"

  if [[ $VM_InstanceName ]]; then
    if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]] ; then
      if [[ $KVM_MSR_status == "N" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi
    elif [[ "$VM_InstanceName" != *windows*  ]] &&	[[ "$VM_InstanceName" != *macos*  ]] ; then
      if [[ $KVM_MSR_status == "Y" ]]; then KVM_MSR_Warn=1 ; else KVM_MSR_Warn= ; fi
    fi
  fi
}

print_kvm_status_warnings () {
  find_kvm_msr_default_and_status
  if [[ $VM_InstanceName ]]; then
    if [[ $KVM_MSR_Warn ]] && [[ $Verbose_MSR_dialog || $MSR_Warnings ]] || [[ ! $MSR_Warnings && $ShowUtilsMenu ]] ; then
      Show_MSR_Warnings=1 ; else Show_MSR_Warnings=
    fi
    if [[ $KVM_MSR_status == "Y" ]] ; then
      [[ $KVM_MSR_Error || $Show_MSR_Warnings ]] && printf "\n  Host Session = Y"
      if  [[ $KVM_MSR_Error ]]; then  printColor "  ERROR > [m] msrs help\n"
      elif [[ $Show_MSR_Warnings ]]; then printf "   [m] msrs help\n"
      fi
    else
      [[ $KVM_MSR_Error || $Show_MSR_Warnings ]] && printf "\n  Host Session = N"
      if [[ $KVM_MSR_Error ]]; then printColor "  ERROR > [m] msrs help\n"
      elif [[ $Show_MSR_Warnings ]] ; then printf "   [m] msrs help\n"
      fi
    fi
  fi
}


toggle_msr_defaults () {

  # Modded & now reversible rewrite of original quickemu's function 'ignore_msrs_always'
  # https://www.linux-kvm.org/page/Category:Docs

  Verbose_MSR_dialog=1

  if [[ ! -d /etc/modprobe.d ]]; then

    printf "\n  ERROR! /etc/modprobe.d was not found. "
    printf "\n\n  See notes, it may be possible to manually create modprobe.d/kvm-quickemu.conf \n\n"

  else

    printColor "\n\n  Configure DEFAULT, boot-up, KVM behaviour "
    printf "for unhandled machine-specific registers "
    find_kvm_msr_default_and_status
    printf "\n\n  Status:  Boot Default = %s"  "$KVM_MSR_default"

    [[ ! $KVM_MSR_ModProbeFile ]] && KVM_MSR_ModProbeFile="/etc/modprobe.d/kvm-quickemu.conf"

    [[ ! -e "$KVM_MSR_ModProbeFile" ]] && printf "\n\n  \'%s\'  needs to be created "  "$KVM_MSR_ModProbeFile"
    printf "\n\n  "
    [[ $KVM_MSR_default == "N" ]] && printColor "[y] to set Y  "
    [[ $KVM_MSR_default == "Y" ]] && printColor "[n] to set N  "
    printf " [b] to go back \n\n"
    read -rp  "  > "  Set_MSR_defaults

    # set .conf file content & update initramfs in all kernels (y/n or none)

    if [[ $Set_MSR_defaults == "y" ]]; then
      printf "\n\n  Updating 'initramfs' may take a moment or two ... \n\n"
      # As per flexiondotorg solution in original quickemu, needs 'tee' to get this to work,
      # but route tee's stdout to null to tidy the screen
      echo "options kvm ignore_msrs=Y" | sudo tee "$KVM_MSR_ModProbeFile" 1> /dev/null
      sudo update-initramfs -k all -u
    elif [[ $Set_MSR_defaults == "n" ]]; then
      printf "\n\n  Updating 'initramfs' may take a moment or two ... \n\n"
      echo "options kvm ignore_msrs=N" | sudo tee "$KVM_MSR_ModProbeFile" 1> /dev/null
      sudo update-initramfs -k all -u
    fi
    if [[ $Set_MSR_defaults != "b" ]]; then
      find_kvm_msr_default_and_status
      # Reset Sudo and any elevated permissions ...
      sudo -k
      printf "\n\n  Status:  Host Session = %s   Boot Default = %s"   "$KVM_MSR_status"  "$KVM_MSR_default"
    fi

  fi

}


show_kvm_msr_general_note () {

  printColor "\n  For frequent use of Windows or MacOS, you should modify the SYSTEM BOOT settings "
  printf   "\n\n  Adjusting the current session will avoid the need for rebooting"
  [[ $MSR_DistrosFound ]] &&  printf "\n\n  Windows or MacOS distros appear present  "

  printColor "\n\n\n  Status:  "
  printf "Host Session = %s   Boot Default = %s"   "$KVM_MSR_status"  "$KVM_MSR_default"
  printf "\n\n  Windows or MacOS should be set to 'Y' whilst Linux distros can generally use either"

}

show_kvm_sudo_security_note () {

  printColor "\n  For SESSION adjustments, qqX requires 'sudo' permissions to echo true or false to 'ignore_msrs'"
  printf   "\n\n  This allows you to create a temporary MSRS status that may be changed at any time,"
  printf   "\n\n  allowing you to match the selected guest VM that you want to run."

  printColor "\n\n\n  qqX will remove any elevated permissions immediately afterwards"

  printf  "\n\n\n  Alternatively, you can issue these commands manually:"
  printf "\n\n  Sudo command to set as Y:  echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs"
  printf "\n\n  Sudo command to set as N:  echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs"
  printf "\n\n  Use shift-crtl-c (or your distro's variant) to copy the displayed sudo command, then"
  printf "\n\n  open a side terminal & use shift-crtl-v to paste and run it.  In this way, elevated permissions"
  printf "\n\n  will only exist in the side terminal and will cease as soon as it is closed."
  printf "\n\n  Return to qqX and select 'leave as ...'  The msrs settings will auto-update. "
  printf "\n\n"

}


select_msr_config () {

  # Normally called when MSRS/OS conflict previously detected,
  # or if selector is being used to change current status.

  find_kvm_msr_default_and_status
  KVM_MSR_selector= ;  Verbose_MSR_dialog=1

  while true ; do

    [[ $KVM_MSR_selector_LoadHelp ]] && show_kvm_msr_general_note

    if [[ $FurtherNoteFlag ]]; then FurtherNoteFlag= ; else  printf "\n\n\n  [f] See the further notes for details"
    fi

    if [[ $MSR_DistrosFound && $KVM_MSR_status == "N" ]]; then
      printColor "\n\n  [y] set current host session to Y "
      printf "  [enter]  leave as N"

    elif [[ $MSR_DistrosFound && $KVM_MSR_status == "Y" ]]; then
      printColor "\n\n  [enter]  leave as Y "
      printf "  [n] set current host session to N"

    elif [[ ! $MSR_DistrosFound && $KVM_MSR_status == "N" ]]; then
      printColor "\n\n  [enter]  leave as N"
      printf "  [y] set current host session to Y"

    elif [[ ! $MSR_DistrosFound && $KVM_MSR_status == "Y" ]]; then
      printColor "\n\n  [n] set current host session to N "
      printf "  [enter]  leave as Y"
    fi

    if [[ $KVM_MSR_selector == "h" ]] || [[ $KVM_MSR_selector_LoadHelp ]] ; then
      printf "   [d] set host system defaults \n\n"
    else  printf "   [h] see help  \n\n"
    fi

    read -rp "  >  "  KVM_MSR_selector
    printf "\n"

    [[ ! $KVM_MSR_selector ]]  &&  break

    if [[ $KVM_MSR_selector == "y" ]] || [[ $KVM_MSR_selector == "n" ]]; then

      # As per the solution in original quickemu, needs 'tee' to get this to work,
      # but route tee's stdout to null to tidy the screen
      [[ $KVM_MSR_selector == "y" ]] &&  echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs  1> /dev/null
      [[ $KVM_MSR_selector == "n" ]] &&  echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs  1> /dev/null

      find_kvm_msr_default_and_status
      # Reset Sudo and any elevated permissions ...
      sudo -k
      printf "\n\n  Status:  Host Session= %s   Boot Default = %s"   "$KVM_MSR_status"  "$KVM_MSR_default"
      printColor "\n\n  [enter]  to return \n\n"
      read -rp  "  > "

      break

    fi

    if [[ $KVM_MSR_selector == "d" ]]; then

      toggle_msr_defaults

      if [[ $Set_MSR_defaults == "b" ]]; then
        Set_MSR_defaults=
        printf "\033c"
        qqX_logo_printf_title "Machine Specific Register controls"
        printf "\n\n"
      else
        find_kvm_msr_default_and_status
        break
      fi

    elif [[ $KVM_MSR_selector == "f" ]]; then

      printf "\033c"
      qqX_logo_printf_title "Machine Specific Register controls"
      printf "\n\n"
      show_kvm_sudo_security_note
      FurtherNoteFlag=1

    fi

  done

  KVM_MSR_selector= ; KVM_MSR_selector_LoadHelp=

}

msrs_conflict_check_resolver() {

  # To be normally run when individual VM menus are loaded, to check for possible problems
  find_kvm_msr_default_and_status
  if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]] ; then
    [[ $ByPass_VM_Array_Selector ]] && MSR_DistrosFound=1
    if [[ $KVM_MSR_status == "N" ]] ; then
      printf "\033c"
      qqX_logo_printf_title "Machine Specific Register controls"
      printf "\n\n"
      show_kvm_msr_general_note
      select_msr_config
      # read new status
      if [[ $KVM_MSR_status == "N" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi
    fi
  fi

}

