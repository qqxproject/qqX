#!/usr/bin/env bash

##  qqX - quickemu quickget X terminal project

#  ADDS IN NEW DISTRO LISTINGS and ALLOWS FUNCTION OVERWRITES
#  qqX component to be located in builtins folder

##  Copyright (c)  Alex Genovese   https://github.com/qqxproject
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.
# 	Otherwise:
#   Licence  GPL3   https://www.gnu.org/licenses

##  May contain MIT licensed snippets or functions from the Quickemu project that have been modified.

## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154

##########################################

## CODING STYLE

#  A more MODERN BASH style of coding is used for qqX than that used for QuickEmu.

#  However, NOT TO WORRY if you are only familiar the older more POSIX styles, there are still plenty of options
#  for contributions to the quickemu built-ins, particularly with this file:

#  4 space tabs may be used with this file, as with QuickGet, so that code can be directly pasted into here and tweaked.
#  2 space is the normal qqX tabbing and may also be employed.
#  Try to keep the tabbing consistent within sections, where possible ...

#  QuickGet and qqX house styles may be mixed, WHICHEVER IS EASIEST. See notes at end for qqX coding style.

##########################################

## To MOD an EXISTING Quickget entry:

#  Copy and paste the relevant functions here, from Quickget, into the Mods script
#  This is normally sections 2 and 3 only, sections 4 to 6 are only for special cases
#  You may also want to add the distro to an existing qqX filter in section 1

## To ADD, place all new work here. Make sure to use the 'osAddList' in section one.

## Explanatory notes are given in all sections:
#  Use distro alphabetical order
#  In section 3, place 'release' immediately followed by 'edition' and then 'get' as a triplet, as needed

#  This script will become sourced when running a Quickget builtin. Any functions here will take precedence.
#  It remains variable isolated from running instances of qqX but it does pick up the qqX library location.
#  Take care to maintain original QuickGet variable name continuity, especially when only modding single functions.

#  To test code, run './quickget --check distroname' etc from a terminal opened in the relevant builtin folder, or use the std qqX UI

##########################################


## 1:  LISTS & FILTERS (alphabetical, space separated and space isolated at each end)

# osAddList for new qqX listed distros
osAddList=" anduinos bluestar "
#osAddList+=" another "

# osRemoveList for distros that are problematic or no longer maintained, but still listed by Quickget
osRemoveList=" arcolinux clearlinux holoiso truenas-core vxlinux "
#osRemoveList+=" another and-one-more "

osSupported="$(os_support)"
osSupported+=" $osAddList "
osSupported="${osSupported//'  '/' '}"
osSupported="$(tr ' ' '\n' <<< "$osSupported" | sort -bd)"
osSupported="$(paste -s -d ' ' <<< "$osSupported")"
osSupported="${osSupported//'  '/' '}"
osSupported_All="$osSupported"

osRemoveList="${osRemoveList//'  '/' '}"
osRemoveList="${osRemoveList//'  '/' '}"
mapfile -t -d ' ' osRemoveArr <<< "$osRemoveList"

## For FILTER CALLS, see/add at start of quick_REROUTE_get
# The call will cause a defined list to be shown by triggering a controlled error state in Quickget ...

osServersList=" alpine centos-stream freedos proxmox-ve "
osServersList+=" truenas-scale ubuntu-server windows-server "
osServersList="${osServersList//'  '/' '}"
osServersList="${osServersList//'  '/' '}"

osGamingList=" batocera bazzite cachyos garuda nobara "
osGamingList+=" popos sparkylinux "
osGamingList="${osGamingList//'  '/' '}"
osGamingList="${osGamingList//'  '/' '}"

osUsbList=" alpine freedos kolibrios "
osUsbList+=" slax slitaz tinycore "
osUsbList="${osUsbList//'  '/' '}"
osUsbList="${osUsbList//'  '/' '}"

osSecList=" athenaos kali "
osSecList+=" parrotsec tails "
osSecList="${osSecList//'  '/' '}"
osSecList="${osSecList//'  '/' '}"

osNoSysDList=" artixlinux devuan "
osNoSysDList+=" mxlinux void "
osNoSysDList="${osNoSysDList//'  '/' '}"
osNoSysDList="${osNoSysDList//'  '/' '}"

# A qqlist- prefix is used to make sure any calls to Quickget don't confuse list names with distro names
# See function 'load_QGW_OS_Array' in the 'reroute_get' script
# Older version mod files will get check for qqlists that don't exist in their particular built-in
# qqlist-all is default (add here for grepping)
if [[ $1 == "qqlist-desktop"  ]] ; then mapfile -t -O "${#osRemoveArr[@]}" -d ' ' osRemoveArr <<< "$osServersList"
elif [[ $1 == "qqlist-server-cl" ]] ; then osSupported="$osServersList"
elif [[ $1 == "qqlist-gaming" ]] ; then osSupported="$osGamingList"
elif [[ $1 == "qqlist-ultra-light" ]] ; then osSupported="$osUsbList"
elif [[ $1 == "qqlist-security" ]] ; then osSupported="$osSecList"
elif [[ $1 == "qqlist-no-sysd" ]] ; then osSupported="$osNoSysDList"
else osSupported="$osSupported_All"
fi

for Rem in "${osRemoveArr[@]}"; do
	osSupported="${osSupported//" $Rem "/' '}"
done

osSupported="${osSupported//'   '/' '}"
osSupported="${osSupported//'  '/' '}"
osSupported="${osSupported//'  '/' '}"

# replace old function, but only after old one has been read
function os_support { echo " $osSupported " ; }

##########################################

## 2: INFO
# Needed for new qqX listed distros or use for INFO overwrites

function os_info {
    local INFO=
    case "$1" in
        #name)            INFO="PrettyName|Credentials|Homepage|Info";;
        anduinos)         INFO="Anduin OS|-|https://www.anduinos.com/|Ubuntu-based Linux distribution that aims to facilitate developers transitioning from Windows.";;
        archlinux)        INFO="Arch Linux|-|https://archlinux.org/|The definitive rolling release, the base of so many other Linux distros, or as the base of your own ...";;
        archcraft)        INFO="Archcraft|-|https://archcraft.io/|Arch based collection of minimal Linux desktop solutions";;
        athenaos)         INFO="Athena OS|-|https://athenaos.org/|NixOS based pentesting distribution using BlackArch package repo";;
        bluestar)         INFO="Blue Star|-|https://sourceforge.net/projects/bluestarlinux/|Arch based, MacOS-like take on KDE Plasma that's easy to use.";;
        crunchbang++)     INFO="Crunchbangplusplus|-|https://www.crunchbangplusplus.org/|The classic minimal crunchbang feel, now with Debian base.";;
        edubuntu)         INFO="Edubuntu|-|https://www.edubuntu.org/|Stable, secure and privacy conscious option for schools.";;
        elementary)       INFO="Elementary OS|-|https://elementary.io/|Streamlined Gnome/Vala/Flatpak distro: Thoughtful, capable, and ethical replacement for Windows and macOS.";;
        endless)          INFO="Endless OS|-|https://www.endlessos.org/os|Gnome/Fedora/Debian immutable os-tree with Flatpak packaging. English/Spanish/Portuguese focus with special tools for Windows users.";;
        fedora)           INFO="Fedora|-|https://www.fedoraproject.org/|Innovative Linux community distros for desktops, clouds, and containers. Security focused and enterprise funded by RedHat and others ...";;
        garuda)           INFO="Garuda Linux|-|https://garudalinux.org/|Arch based Linux distribution. Minimal or opinionated Full styling with option packs.";;
        kolibrios)        INFO="KolibriOS|-|https://git.kolibrios.org/|Tiny yet incredibly powerful and fast operating system.";;
        manjaro)          INFO="Manjaro|-|https://manjaro.org/|Arch based, curated slow roll distro with lots of pre-supplied packaging, targetting personal or enterprise.";;
        mxlinux)          INFO="MX Linux|-|https://mxlinux.org/|Medium weight Debian Stable based distro with Systemd or sysVinit";;
        nitrux)           INFO="Nitrux|-|https://nxos.org/|Innovative Linux distro powered by the Cachy kernel with NX AppHub, Hyprland, Waybar and Crystal dock.";;
        slint)            INFO="Slint|-|https://slint.fr/|BLIND-FRIENDLY, easy-to-use, versatile Linux distribution for 64-bit computers. Slint is based on Slackware and borrows tools from Salix. Maintainer: Didier Spaier.";;
        trisquel)         INFO="Trisquel|-|https://trisquel.info/|The free GNU operating system, with the kernel GNU Linux-libre. Choice of 3 desktops or the 'Sugar' learning environment.";;
        tinycore)         INFO="Tiny Core Linux|-|http://www.tinycorelinux.net/|Nomadic ultra small graphical desktop operating system capable of booting from cdrom, pendrive, or frugally from a hard drive.";;
        void)             INFO="Void Linux|anon:voidlinux|https://voidlinux.org/|Non-Systemd desktop operating system based on Runit. Software is provided in binary packages or can be built directly from sources.";;
    esac
	[[ ! $INFO ]] && INFO="$(os_info_QG "$1")"
    echo "$INFO"
}

# Add release/installation notes where needed, omit if not.

function distro_release_notes {
    local RelNotes=
    case "$1" in
        #name)            RelNotes="mm/yyyy (as needed)  Notes on installation or problems to watch out for";;
        artixlinux)       RelNotes="06/2025 The new online install option is still work-in-progress, users are advised to select 'Offline' when prompted.";;
        athenaos)         RelNotes="https://github.com/Athena-OS/athena/releases";;
        elementary)       RelNotes="08/2025 Although \$0 is possible, due to a donation request paywall, possible auto-downloads may not be the latest. See website.";;
        endless)          RelNotes="08/2025 Difficult to grep for auto-downloads, due JS rendered webpages, so may not be the latest. See website, for more.";;
        fedora)           RelNotes="11/2025 Tested as ALL working. KDE and Workstation/Gnome are Official. Others are Spins. New unlisted Spins may exist ....";;
        macos)            RelNotes="06/2025 Sequoia is currently having issues with slow running. See qqX issue #9";;
        mxlinux)          RelNotes="For Community Spins and sysVinit variants, see website for direct download";;
        nitrux)           RelNotes="11/2025 https://nxos.org/changelog/release-announcement-nitrux-5-0-0/";;
        opensuse)         RelNotes="11/2025 Tumbleweed is the main focus. Leap has now become inconsistent and/or absent";;
        rockylinux)       RelNotes="Also available in Server versions. For major release upgrades, run a fresh install";;
        sparkylinux)      RelNotes="07/2025 Older specialist versions: 'gameover' 'multimedia' and 'rescue' are available via manual download";;
        tinycore)         RelNotes="Core is 32 bit 17Mb CLI, Tiny is 23Mb whilst Plus is around 230Mb. Select Pure for 64 bit.";;
        void)             RelNotes="To install the packages for the desktop environment, DON'T choose 'install from network' choose the 'local install' option.";;
    esac
    echo "$RelNotes"
}

##########################################

## 3: RELEASES, EDITIONS and DOWNLOAD URL
# Needed for new qqX listed distros or use for "releases_${OS} ()" and "editions_${OS} ()" overwrites.

# Quickget's behaviour is to continually exit on error until the correct input combination is made.
# This means that Quickget probes normally have to be carried out via repeated and discontiguous command line args requests
# and that the use of global variables is either limited or not possible:

# IF CHECKING editions, the var $RELEASE becomes available in the function editions_$OS
# When running complete distro checks, via './quickget --check distroname', this uses function 'test-all' and
# both vars $RELEASE & $EDITION become available in the 'get' function.

# The first two FUNCTIONS feed STDOUT to the look-up function 'validate_release' followed by
# the last lines of Quickget where distro editions are handled.

# Transfer files may also be implemented:
# See 'editions_anduinos' for a more complex example script and 'get_parrotsec' for simpler cases
# Some distros single release with no editions eg. bluestar

# Quickget's legacy behaviour is to return a 'STOCK LIST' of editions when no release is supplied ...
# Probably has room for improvement but a list should be given.
# See 'editions_gnomeos' for a per edition check routine, where some may be absent.

# Note that Quickget's 'web_pipe()' is an alias for Curl and will generate STDOUT by itself, without needing 'echo'.
# Also that further echoes can be avoided via Bash's <<< 'herestring' feature.

# THE 'GET' FUNCTION should generate the download target and a checksum.
# Quickget often employs local variables $URL and $HASH but any format may be used.
# The last line should supply the DOWNLOAD TARGET TO STDOUT to $1, to be read by create_vm() or test-all() etc.
# If available, the checksum should be downloaded, cleaned and supplied to $2.

# Where possible, try to keep web greps dynamic. This is made easier with 'floatversion' and may include 'fv' pipes.
# See https://github.com/TuxVinyards/floatversion

# Place standard sized 'get' functions here, next to releases and editions, and any oversized ones in section 7.
# Downloads may occasionally need a special tidy-up and finalization. See sections 4 to 6.

# For testing code, run './quickget --check distroname' from a terminal opened in the relevant builtin folder.

## FIX the original FreeSpirit mod to stop pre-release Alpine dev work getting listed
function releases_alpine() {
    CurrAlp="$(web_pipe "https://alpinelinux.org/downloads/" | grep -s 'Current Alpine' | fv -M -Q | cut -d '.' -f 1,2)"
    ListAlp="$(web_pipe "https://dl-cdn.alpinelinux.org/alpine/" | fv -M 6 -Q --col)"
    mapfile -t ArrAlp <<< "$ListAlp"
    RelAlpCount=0 ; ArrAlpCount=0 ; RelList=
    while [[ ${ArrAlp[ArrAlpCount]} ]] && [[ "$RelAlpCount" -lt 4 ]]; do
        if ! fv --gt "${ArrAlp[ArrAlpCount]} $CurrAlp "; then
            RelList+="${ArrAlp[ArrAlpCount]} " ; ((RelAlpCount+=1))
        fi
        ((ArrAlpCount+=1))
    done
    echo "$RelList"
}

## ADD
function releases_anduinos {
    echo "LTS Standard"
}
function editions_anduinos {
    if [[ ! $RELEASE ]]; then
        echo "ar_SA de_DE en_GB en_US es_ES fr_FR it_IT ja_JP ko_KR nl_NL pl_PL pt_BR pt_PT ru_RU sv_SE th_TH tr_TR vi_VN zh_CN zh_HK zh_TW"
        return 0  # Stock List @ June 2025
    fi
    # Otherwise check for editions per release
    while true ; do
        if ! { grep -qs "$OS" "/tmp/qGet.Mods.REL.data.txt" && grep -s 'ReleaseName=' "/tmp/qGet.Mods.REL.data.txt" | grep -qs "$RELEASE"; } ; then
            printf "qGetDistro=\"%s\"\nReleaseName=\"%s\"" "$OS" "$RELEASE" > "/tmp/qGet.Mods.REL.data.txt"
            if [[ $RELEASE == "LTS" ]]; then ReleaseNumber="$(web_pipe "https://docs.anduinos.com/VERSIONS.html" |tr '>' '\n' | grep '</td' | grep LTS | fv -M -Q)"
            else ReleaseNumber="$(web_pipe "https://docs.anduinos.com/VERSIONS.html" |tr '>' '\n' | grep '</td' | grep -v LTS | fv -M -Q)"
            fi
            ReleasePoint="$(web_pipe "https://download.anduinos.com/${ReleaseNumber}/" | grep href | fv -M -Q )"
            ReleaseEditions="$(web_pipe "https://download.anduinos.com/${ReleaseNumber}/${ReleasePoint}" \
            | grep -v sha256 | grep -v torrent | tr '>' '\n' | grep iso | grep -v '<a' | cut -d'<' -f1 | cut -d'-' -f3 | cut -d'.' -f1 | paste -s -d' ')"
            printf "\nReleaseName=\"%s\"\nReleaseNumber=\"%s\"\nReleasePoint=\"%s\"\nReleaseEditions=\"%s\"" "$RELEASE" "$ReleaseNumber" "$ReleasePoint" "$ReleaseEditions" > "/tmp/qGet.Mods.REL.data.txt"
            sleep 1
        fi
        ReleaseName= ; ReleaseNumber= ; ReleasePoint= ; ReleaseEditions=
        source "/tmp/qGet.Mods.REL.data.txt"
        if [[ $ReleaseName && $ReleaseNumber && $ReleasePoint && $ReleaseEditions ]] ; then break
        else printf "" > "/tmp/qGet.Mods.REL.data.txt"
        fi
    done
    printf "%s" "$RELEASE" > "/tmp/qGet.Mods.ED.data.txt"
    printf "" > "/tmp/qGet.Mods.GET.data.txt"
    [[ ! $ReleaseEditions ]] && source "/tmp/qGet.Mods.REL.data.txt"
    echo "$ReleaseEditions"
}
function get_anduinos {
    source "/tmp/qGet.Mods.REL.data.txt"
    # for looping through test-all
    sleep 0.5
    AnduinIso="https://download.anduinos.com/${ReleaseNumber}/${ReleasePoint}/AnduinOS-${ReleasePoint}-${EDITION}.iso"
    AnduinHash="$(web_pipe "https://download.anduinos.com/${ReleaseNumber}/${ReleasePoint}/AnduinOS-${ReleasePoint}-${EDITION}.sha256" \
    | cut -d':' -f2 | tr -cd '[:graph:]')"
    echo "$AnduinIso $AnduinHash"
    printf "%s" "$EDITION" > "/tmp/qGet.Mods.GET.data.txt"
}

## FIX Arch - Pre-emptively for PR  https://github.com/quickemu-project/quickemu/pull/1709
function get_archlinux() {
    local HASH=""
    local ISO=""
    local URL="https://geo.mirror.pkgbuild.com"
    ISO=$(web_pipe "https://archlinux.org/releng/releases/json/" | jq -r '.releases[0].iso_url')
    HASH=$(web_pipe "https://archlinux.org/releng/releases/json/" | jq -r '.releases[0].sha256_sum')
    echo "${URL}${ISO} ${HASH}"
}

## FIX artix community editions and hash grep
function get_artixlinux() {
    local HASH="" ; local ISO=""
    local URL="https://download.artixlinux.org/iso"
    if [[ $EDITION == "community-gtk" ]]; then ISO="artix-community-gtk-openrc-${RELEASE}-x86_64.iso"
    elif [[ $EDITION == "community-qt" ]]; then ISO="artix-community-qt-openrc-${RELEASE}-x86_64.iso"
    else ISO="artix-${EDITION}-${RELEASE}-x86_64.iso"
    fi
    HASH=$(web_pipe "${URL}/sha256sums" | grep -s "${ISO}" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## UPDATE new repo
function releases_athenaos() {
    web_pipe "https://github.com/Athena-OS/athena/releases" | grep 's/tag' | fv -Q -M 2
}
function get_athenaos() {
    local HASH=""
    local URL="https://github.com/Athena-OS/athena/releases/download/v${RELEASE}/athenaos-live-x86_64.iso"
    # eg https://github.com/Athena-OS/athena/releases/download/v25.11/athenaos-live-x86_64.iso
    HASH=$(web_pipe "${URL}.sha256" | cut -d' ' -f1)
    echo "${URL} ${HASH}"
}

## UPDATE url
function get_blendos() {
    local HASH=""
    local URL="https://at.blendos.niranjan.co/blendOS.iso"
    echo "${URL} ${HASH}"
}

## ADD
function releases_bluestar {
    echo "latest"
}
function get_bluestar {
    BlueStarRelease="$(web_pipe https://sourceforge.net/projects/bluestarlinux/files/distro/ \
    | grep green | grep title | cut -d'=' -f4 | cut -d':' -f1 | cut -d'/' -f3)"
    BlueStarIso="https://sourceforge.net/projects/bluestarlinux/files/distro/${BlueStarRelease}"
    BlueStarHash="https://sourceforge.net/projects/bluestarlinux/files/distro/${BlueStarRelease/iso/md5}"
    BlueStarHash="$(web_pipe "$BlueStarHash" | cut -d' ' -f1)"
    echo "$BlueStarIso $BlueStarHash"
}

## FIX bodhi editions
function editions_bodhi() {
    if [[ ! $RELEASE ]]; then echo "standard hwe s76"
    elif  fv -Q --gt "$RELEASE 6.9" ; then echo "standard hwe s76"
    else echo "standard hwe"
    fi
}

## FIXES for Devuan - make dynamic     #echo daedalus chimaera beowulf
function releases_devuan() {
    local ReadMeTxt= ; ReadMeTxt=$(web_pipe "https://files.devuan.org/README.txt")
    mapfile -t  Dlist <<< "$(grep -s Devuan <<< "$ReadMeTxt" | grep -v archived | fv -c -M 3 -Q)"
    local DlistStr=
    for D in "${Dlist[@]}"; do
        grep -s Devuan <<< "$ReadMeTxt" | grep "$D" | cut -d' ' -f6- | tr ' ' '_'
    done
}
function get_devuan() {
    local HASH="" ; local ISO="" ; local VER="" ; local URL=
    RELEASE="$(tr -cd '[:alpha:]' <<< "$RELEASE" | tr -cd '[:graph:]')"
    RELEASE="devuan_${RELEASE,,}"
    URL="https://files.devuan.org/${RELEASE}/desktop-live"
    VER="$(web_pipe "$URL" | grep -s -m 1 "amd64_desktop" | cut -d '>' -f 1 | fv -Q | tr -cd '[:graph:]')"
    ISO="${RELEASE}_${VER}_amd64_desktop-live.iso"
    HASH=$(web_pipe "${URL}/${ISO}.sha256" | grep -s amd64 | cut -d' ' -f1)
    [[ ! $HASH ]] && HASH=$(web_pipe "${URL}/SHA256SUMS.txt" | grep -s amd64 | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## REDUCE release count - over 20 is too many!
function releases_dragonflybsd() {
    # If you remove "".bz2" from the end of the searched URL, you will get only the current release
   web_pipe "https://mirror-master.dragonflybsd.org/iso-images/" | grep -E -o '"dfly-x86_64-.*_REL.iso.bz2"' | grep -o -E '[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+' | fv -M 5 -qs
}

## FIX Easy OS release list
function releases_easyos() {
    local ALL_RELEASES="" ; local YEAR=""
    # get the latest 2 years of releases so that when we hit next year we still have the latest 2 years
    TWO_YEARS=$(web_pipe https://distro.ibiblio.org/easyos/amd64/releases/kirkstone/ | grep -o -E '[[:digit:]]{4}/' | sort -nr | tr -d /  | head -n 2 )
    for YEAR in ${TWO_YEARS} ; do
        ALL_RELEASES="${ALL_RELEASES} $(web_pipe https://distro.ibiblio.org/easyos/amd64/releases/kirkstone/"${YEAR}"/ | grep -o -E '[[:digit:]]+(\.[[:digit:]])+/' | tr -d / )"
    done
    ALL_RELEASES="$(floatversion -qs -r "$ALL_RELEASES")"
    echo "${ALL_RELEASES}"
}

## FIX Cosmic Atomic - tested as ALL working @ 09/2025 but there are possibly new unlisted editions, see https://fedoraproject.org/
function get_fedora() {
    local HASH="" ; local ISO="" ; local JSON="" ; local URL="" ; local VARIANT=""
    case ${EDITION} in
        KDE) if [[ $RELEASE -ge 42 ]]; then VARIANT="${EDITION}"; else VARIANT="Spins"; fi ;;
        Server|Kinoite|Onyx|Silverblue|Sericea|Workstation|COSMIC-Atomic) VARIANT="${EDITION}";;
        *) VARIANT="Spins";;
    esac
    # The naming of 41 Beta with a space is problematic so we replaced it with an underscore but we need to convert it back to a space
    # for the URL search in the JSON if RELEASE contains an underscore, replace it with a space
    [[ "${RELEASE}" == *"_"* ]] && RELEASE="${RELEASE/_/ }"
    # shellcheck disable=SC2086
    JSON=$(web_pipe_json "https://getfedora.org/releases.json" | jq '.[] | select(.variant=="'${VARIANT}'" and .subvariant=="'"${EDITION}"'" and .arch=="x86_64" and .version=="'"${RELEASE}"'" and (.link | endswith(".iso")))')
    URL=$(echo "${JSON}" | jq -r '.link' | head -n1)
    HASH=$(echo "${JSON}" | jq -r '.sha256' | head -n1)
    echo "${URL} ${HASH}"
}

## FIX & UPDATE to current format
function releases_gnomeos() {
    web_pipe "https://download.gnome.org/gnomeos/" | grep -s href | grep link | fv -M 3 -Q
}
function editions_gnomeos() {
    if [[ ! $RELEASE ]]; then  echo "release rc beta alpha"
    else
        local GnomeBase= ; GnomeBase="${RELEASE/%.*}"
        local GnomeFolder= ; local BaseUrl= ; local ISO= ; local GnomeChk= ; local GnomeEditions=
        for GnomeChk in release rc beta alpha ; do
            case $GnomeChk in
                release)    GnomeFolder="${GnomeBase}.0" ;;
                rc)         GnomeFolder="${GnomeBase}.rc" ;;
                beta)       GnomeFolder="${GnomeBase}.beta" ;;
                alpha)      GnomeFolder="${GnomeBase}.alpha" ;;
            esac
            BaseUrl="https://download.gnome.org/gnomeos/${GnomeFolder}"
            # each folder has the latest only, but alpha may exist without beta and rc etc
            ISO="$(web_pipe "$BaseUrl" | grep -s href | tr ' ' '\n' | grep title | head -n 1 | cut -d'"' -f2 )"
            [[ "$ISO" == *'.iso' ]] && GnomeEditions+="$GnomeChk "
        done
        echo "$GnomeEditions"
    fi
}
function get_gnomeos() {
    local GnomeBase= ; GnomeBase="${RELEASE/%.*}" ; local GnomeFolder= ; local BaseUrl= ; local ISO=
    case $EDITION in
        release)    GnomeFolder="${GnomeBase}.0" ;;
        rc)         GnomeFolder="${GnomeBase}.rc" ;;
        beta)       GnomeFolder="${GnomeBase}.beta" ;;
        alpha)      GnomeFolder="${GnomeBase}.alpha" ;;
    esac
    BaseUrl="https://download.gnome.org/gnomeos/${GnomeFolder}"
    # each folder has the latest only, plus NO checksum eg. alpha.8.iso  Pick the list top just in case of changes. (REVIEW)
    ISO="$(web_pipe "$BaseUrl" | grep -s href | tr ' ' '\n' | grep title | head -n 1 | cut -d'"' -f2 )"
    echo "$BaseUrl/$ISO"
}

## FIX url and make dynamic (no hash available)
function releases_guix() {
    web_pipe "https://ftpmirror.gnu.org/gnu/guix" | grep -s -e 'system-install' | tr '<' '\n' | grep href | fv -M 2 -Q
}
function get_guix() {
    local ISO="guix-system-install-${RELEASE}.x86_64-linux.iso"
    local URL="https://ftpmirror.gnu.org/gnu/guix"
    echo "${URL}/${ISO}"
}

## FIX iso url
function get_kdeneon() {
    local HASH= ; local ISO= ; local URL= ; local NeonVer=
    URL="https://files.kde.org/neon/images/${RELEASE}/current"
    if [[ $RELEASE == "developer" ]]; then NeonVer="unstable-developer"; else NeonVer="$RELEASE"
    fi
    ISO="neon-${NeonVer}-current.iso"
    HASH=$(web_pipe "${URL}/neon-${NeonVer}-current.sha256sum" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## FIX omit dirs only having an RC sub-folder
function releases_linuxlite() {
    local ReleasesList= ; local ReleasesTrue= ; i=0
    ReleasesList="$(floatversion -M 5 -qs "$(web_pipe "https://sourceforge.net/projects/linux-lite/files/" | grep -s 'class="name')")"
    for ChkRel in $ReleasesList; do
        web_check "https://sourceforge.net/projects/linux-lite/files/${ChkRel}/linux-lite-${ChkRel}-64bit.iso" &&  ReleasesTrue+="$ChkRel "
        ((i++)) ; [[ $i -gt 3 ]] && break
    done
    echo "$ReleasesTrue"
}

## FIX update mirror
function get_linuxmint() {
    local HASH=""
    local ISO="linuxmint-${RELEASE}-${EDITION}-64bit.iso"
    #local URL="https://mirror.bytemark.co.uk/linuxmint/stable/${RELEASE}"
    local URL="https://mirror.rackspace.com/linuxmint/iso/stable/${RELEASE}"
    HASH=$(web_pipe "${URL}/sha256sum.txt" | grep "${ISO}" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## UPGRADE only one release ... make dynamic
function releases_mageia() {
    web_pipe "https://www.mageia.org/en/downloads" | grep Download | grep strong | cut -d'M' -f2 | cut -d' ' -f2
}

## FIX manjaro sway
function get_manjaro() {
    local HASH="" ; local ISO="" ; local MANIFEST="" ; local URL="" ; local TYPE="official"
    MANIFEST="$(web_pipe https://gitlab.manjaro.org/web/iso-info/-/raw/master/file-info.json)"
    case "${RELEASE}" in
        sway) MANIFEST="$(web_pipe https://mirror.manjaro-sway.download/manjaro-sway/release.json)" ; TYPE="sway" ;;
        cinnamon|i3) TYPE="community";;
    esac
    if [ "${EDITION}" == "minimal" ] && [ "${TYPE}" != "sway" ]; then EDITION=".minimal"
    else EDITION=""
    fi
    if [ "${RELEASE}" == "sway" ]; then
        URL=$(echo "${MANIFEST}" | jq -r '.[] | select(.name|test("^manjaro-sway-.*[.]iso$")) | .url' | grep -v 'unstable')
    else
        URL="$(echo "${MANIFEST}" | jq -r ."${TYPE}.${RELEASE}${EDITION}".image)"
    fi
    HASH=$(web_pipe "${URL}.sha512" | cut -d' ' -f1)
    echo "${URL} ${HASH}"
}

## UPDATE to FIX release numbers varying with flavor
function releases_mxlinux() {
    echo latest
}
function editions_mxlinux() {
    echo Xfce KDE Fluxbox
}
function get_mxlinux() {
    local HASH= ; local URL= ; local ISO= ; local RELEASE=
    URL="https://sourceforge.net/projects/mx-linux/files/Final/${EDITION}"
    #RELEASE="$(web_pipe "$URL" | tr '<' '\n' | grep -s href | grep latest | cut -d'=' -f2 | fv -Q -M)"
    RELEASE="$(web_pipe "$URL" | tr '<' '\n' | grep -s href | grep latest | tr '/' '\n' | grep -e 'MX-' | cut -d '_' -f1 | cut -d '-' -f2)"
    # eg https://sourceforge.net/projects/mx-linux/files/Final/KDE/MX-23.6.1_KDE_x64.iso.sha256/download
    # eg https://sourceforge.net/projects/mx-linux/files/Final/Fluxbox/MX-25_fluxbox_x64.iso/download
    # eg https://sourceforge.net/projects/mx-linux/files/Final/Xfce/MX-25_Xfce_x64.iso/download
    case ${EDITION} in
        Xfce) ISO="MX-${RELEASE}_Xfce_x64.iso";;
        KDE) ISO="MX-${RELEASE}_KDE_x64.iso";;
        Fluxbox) ISO="MX-${RELEASE}_fluxbox_x64.iso";;
    esac
    HASH=$(web_pipe "${URL}/${ISO}.sha256" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## FIX and UPDATE to new folder styles and names
function releases_opensuse() {
    #echo "leap leap-micro slowroll tumbleweed"  @ 11/2025 leap has become inconsistent and/or absent
    echo "leap-micro slowroll tumbleweed"
}
function editions_opensuse() {
    if [[ ! $RELEASE ]]; then echo "DVD Gnome KDE XFCE Rescue"
    elif [[ $RELEASE == "leap" ]]; then echo "Gnome KDE XFCE Rescue"
    elif [[ $RELEASE == "leap-micro" ]]; then echo current
    elif [[ $RELEASE == "slowroll" ]]; then echo DVD
    elif [[ $RELEASE == "tumbleweed" ]]; then echo "DVD Gnome KDE XFCE Rescue"
    fi
}
function get_opensuse() {
    local HASH="" ; local ISO="" ; local URL="" ; local SuseEdition=  ; local SuseRollPoint=
    case $EDITION in
        DVD)        SuseEdition="DVD" ;;
        Gnome)      SuseEdition="GNOME-Live" ;;
        KDE)        SuseEdition="KDE-Live" ;;
        XFCE)       SuseEdition="XFCE-Live" ;;
        Rescue)     SuseEdition="Rescue-CD" ;;
    esac
    if [ "${RELEASE}" == "tumbleweed" ]; then
        URL="https://download.opensuse.org/tumbleweed/iso"
        ISO="openSUSE-Tumbleweed-${SuseEdition}-x86_64-Current.iso"
    elif [ "${RELEASE}" == "leap" ]; then
        URL="https://download.opensuse.org/distribution/openSUSE-current/live"
        ISO="$(web_pipe "$URL" | tr '>' '\n' |  grep x86 | grep -e 'iso\"' | cut -d '"' -f 2 | cut -d '/' -f 2 | grep -v Build | grep -e "$SuseEdition"  )"
    elif [ "${RELEASE}" == "leap-micro" ]; then
        URL="https://download.opensuse.org/distribution/leap-micro-current/product/iso"
        ISO="$(web_pipe "$URL" | tr '>' '\n' | grep -i -s -e 'current\.iso' | grep x86 | grep -v mirror | grep href | cut -d '"' -f 2 | cut -d '/' -f 2 | grep -v sha256)"
    elif [ "${RELEASE}" == "slowroll" ]; then
        URL="https://download.opensuse.org/slowroll/iso"
        SuseRollPoint="$(web_pipe "$URL" | tr '<' '\n' | grep href | grep -s DVD | cut -d '"' -f 2 | cut -d '-' -f 5 | fv -M -Q)"
        ISO="$(web_pipe "$URL" | tr '<' '\n'| grep href | grep DVD | cut -d '"' -f 2 | grep -s -v -e 'iso\.' | grep -v -e 'x\.' | grep "$SuseRollPoint" | cut -d '/' -f 2)"
    fi
    HASH="$(web_pipe "$URL/${ISO}.sha256" | cut -d ' ' -f 1)"
    echo "$URL/${ISO} $HASH"
}

## FIX - make sure integers -gt 9 can be used ...
# eg. 6.10 and 10.0 > OracleLinux-R6-U10-Server-x86_64-dvd.iso and OracleLinux-R10-U0-x86_64-dvd.iso
function releases_oraclelinux() {
    #echo 9.3 9.2 9.1 9.0 8.9 8.8 8.7 8.6 8.5 8.4 7.9 7.8 7.7
    floatversion -qs -M 4  "$(web_pipe "https://yum.oracle.com/oracle-linux-isos.html" | grep -s -e '<td><strong>')"
}
function get_oraclelinux() {
    local HASH="" ; local ISO="" ; local VER_MAJ= ; local VER_MIN=
    #local VER_MAJ=${RELEASE::1} #local VER_MIN=${RELEASE:2:1}
    VER_MAJ=${RELEASE/.*/} ; VER_MIN=${RELEASE/*./}
    local URL="https://yum.oracle.com/ISOS/OracleLinux/OL${VER_MAJ}/u${VER_MIN}/x86_64"
    case ${VER_MAJ} in
        7) ISO="OracleLinux-R${VER_MAJ}-U${VER_MIN}-Server-x86_64-dvd.iso";;
        *) ISO="OracleLinux-R${VER_MAJ}-U${VER_MIN}-x86_64-dvd.iso";;
    esac
    HASH=$(web_pipe "https://linux.oracle.com/security/gpg/checksum/OracleLinux-R${VER_MAJ}-U${VER_MIN}-Server-x86_64.checksum" | grep "${ISO}" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## FIX hashes and folders
function releases_parrotsec() {
  # July 2025 > only latest folder now has iso's
  Parrot_Latest="$(web_pipe "https://deb.parrot.sh/parrot/iso/" | grep -s href | fv -Q -M)"
  echo latest
}
function editions_parrotsec() {
    echo home htb security
}
function get_parrotsec() {
    local HASH="" ; local ISO="" ; local URL="" ; local LATEST="$Parrot_Latest"
    [[ ! $LATEST ]] && LATEST="$(web_pipe "https://deb.parrot.sh/parrot/iso/" | grep -s href | fv -Q -M)"
    ISO="Parrot-${EDITION}-${LATEST}_amd64.iso"
    URL="https://deb.parrot.sh/parrot/iso/${LATEST}"
    HASH="$(web_pipe "${URL}/signed-hashes.txt" | grep -s -A 30 'sha256' | grep -B 30 'sha384' | grep "${ISO}" | cut -d' ' -f1)"
    echo "${URL}/${ISO} ${HASH}"
}

## FIX hash, update url and make dynamic
function releases_pclinuxos() {
    echo latest
}
function editions_pclinuxos() {
    echo kde kde-darkstar mate xfce
}
function get_pclinuxos() {
    local HASH= ; local ISO= ; local URL= ; local RelMax= ; local RelChk="${EDITION}-2"
    URL="https://ftp.nluug.nl/os/Linux/distr/pclinuxos/pclinuxos/iso/"
    RelMax="$(web_pipe "$URL" | grep -e "$RelChk" | tr '=' '\n' | grep iso | fv -M)"
    HASH="$(web_pipe "${URL}/pclinuxos64-${EDITION}-${RelMax}.md5sum" | cut -d' ' -f1)"
    ISO="pclinuxos64-${EDITION}-${RelMax}.iso"
    echo "${URL}/${ISO} ${HASH}"
}

## UPDATE and FIX
function releases_rockylinux() {
    local BaseGrep= ; local ReleasesList=
    BaseGrep="$(web_pipe "https://dl.rockylinux.org/vault/rocky/" | tr ':' '\n' | grep link)"
    ReleasesList+=" $(fv -S 10 -M -Q <<< "$BaseGrep")"
    ReleasesList+=" $(fv -S 9 -M -Q <<< "$BaseGrep")"
    ReleasesList+=" $(fv -S 8 -M -Q <<< "$BaseGrep")"
    echo "$ReleasesList"
}
function editions_rockylinux() {
    if [[ "$RELEASE" == '10'* ]]; then echo "Gnome KDE"
    elif [[ "$RELEASE" == '9'* ]]; then echo "Cinnamon Gnome KDE Mate Xfce"
    elif [[ "$RELEASE" == '8'* ]]; then echo "Gnome KDE Mate Xfce"
    else echo "Cinnamon Gnome KDE Mate Xfce"
    fi
}
function get_rockylinux() {
    local HASH= ; local URL= ; local ISO=
    RelInt=${RELEASE%.*}
    case $EDITION in
        Gnome)  EDITION="Workstation";;
        Mate)  EDITION="MATE";;
        Xfce)  EDITION="XFCE";;
    esac
    # eg https://dl.rockylinux.org/vault/rocky/10.0/live/x86_64/Rocky-10-Workstation-x86_64-latest.iso.CHECKSUM
    URL="https://dl.rockylinux.org/vault/rocky/${RELEASE}/live/x86_64"
    ISO="Rocky-${RelInt}-${EDITION}-x86_64-latest.iso"
    HASH=$(web_pipe "${URL}/${ISO}.CHECKSUM" | grep -s 'SHA256' | awk '{print $NF}')
    echo "${URL}/${ISO} ${HASH}"
}

## FIX url and hash, plus make dynamic (if list happens to show up)
function get_siduction() {
    local HASH="" ; local DATE="" ; local ISO="" ; local NAME="" ; local URL="" ; local Data=
    NAME=$(web_pipe "https://mirror.math.princeton.edu/pub/siduction/iso/" | grep folder | cut -d'"' -f8 | tr -d '/')
    URL="https://mirror.math.princeton.edu/pub/siduction/iso/${NAME}/${EDITION}"
    Data="$(web_pipe "${URL}"| grep .iso.md5)"
    VERSION="$(cut -d'-' -f2 <<< "$Data" | fv -M)"
    DATE="$(grep "${VERSION}" <<< "$Data" | cut -d'-' -f6 | cut -d'.' -f1)"
    ISO="siduction-${VERSION}-${NAME}-${EDITION}-amd64-${DATE}.iso"
    HASH=$(web_pipe "${URL}/${ISO}.md5" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## FIX  SLINT (only 15.0, and hopefully higher, has downloadable iso's)
function releases_slint() {
    web_pipe "https://slackware.uk/slint/x86_64/" | grep -e '<a href=' | fv -M -Q
}
function get_slint() {
    local HASH="" ; local MIN_VER= ; local URL=
    MIN_VER="$(web_pipe "https://slackware.uk/slint/x86_64/slint-$RELEASE/iso" | grep -e '<a href=' | grep -s -e 'iso\.sha' | fv -f -M -Q | tr -cd '[:graph:]')"
    local ISO="slint64-${MIN_VER}.iso"
    local URL="https://slackware.uk/slint/x86_64/slint-${RELEASE}/iso"
    HASH=$(web_pipe "${URL}/${ISO}.sha256" | cut -d' ' -f1)
    echo "${URL}/${ISO}" "${HASH}"
}

## UPDATE and FIX
function releases_solus() {
    echo latest
}
function editions_solus() {
    web_pipe "https://getsol.us/download/" | grep iso | tr ':' '\n' | grep Release | awk '{print $1}' | cut -d'-' -f3- | grep iso | cut -d'-' -f2 | sort -u | paste -s -d ' '
}
function get_solus() {
    # eg https://downloads.getsol.us/isos/2025-11-29/Solus-Budgie-Release-2025-11-29.iso.sha256sum.sign
    local HASH= ; local BaseUrl= ; local URL=
    BaseUrl="https:""$(web_pipe "https://getsol.us/download/" | grep iso | tr ':' '\n' | grep Release | awk '{print $1}' | grep "$EDITION" | grep sign)"
    HASH="${BaseUrl/.sign/}"
    URL="${HASH/.sha256sum/}"
    HASH="$(web_pipe "$HASH" | cut -d' ' -f1)"
    echo "${URL} ${HASH}"
}

## UPDATE
function releases_sparkylinux() {
    echo "Rolling Stable"
}
function editions_sparkylinux() {
    # May 2025 > listing task tends to exceed quickget's capabilities but July 2025 now allows Mods installer notes
    # Website subject to change, plus older specialist versions still being listed in addition to the newer ones
    if [[ ! $RELEASE ]]; then  echo "LXQt MATE Xfce KDE MinimalGUI MinimalCLI"
    elif [[ $RELEASE == "Rolling" ]] ; then echo "LXQt MATE Xfce KDE MinimalGUI MinimalCLI"
    elif [[ $RELEASE == "Stable" ]] ; then echo "LXQt MATE Xfce KDE MinimalGUI MinimalCLI"
    fi
}
function get_sparkylinux() {
    local HASH="" ; local ISO="" ; local URL="" ; SparkyFolder= ; ReleaseNumber=
    # Stable    https://sourceforge.net/projects/sparkylinux/files/lxqt/sparkylinux-7.7-x86_64-lxqt.iso/download
    # Stable    https://sourceforge.net/projects/sparkylinux/files/base/sparkylinux-7.7-x86_64-minimalgui.iso/download
    # Rolling   https://sourceforge.net/projects/sparkylinux/files/lxqt/sparkylinux-2025.03-x86_64-lxqt.iso/download
    # Rolling   https://sourceforge.net/projects/sparkylinux/files/base/sparkylinux-2025.03-x86_64-minimalgui.iso/download
    #           https://sourceforge.net/projects/sparkylinux/files/lxqt/sparkylinux-2025.09-x86_64-lxqt.iso/download
    #           https://sourceforge.net/projects/sparkylinux/files/mate/sparkylinux-2025.09-x86_64-mate.iso/download
    # But not all roll at the same speed:
    # eg.       https://sourceforge.net/projects/sparkylinux/files/kde/sparkylinux-2024.12-x86_64-kde.iso/download

    EDITION="${EDITION,,}"
    case "$EDITION" in
        minimalcli*)    SparkyFolder="cli" ;;
        minimalgui*)    SparkyFolder="base" ;;
                  *)    SparkyFolder="$EDITION" ;;
    esac
    URL="https://sourceforge.net/projects/sparkylinux/files/${SparkyFolder}"
    if [[ $RELEASE == "Rolling" ]]; then ReleaseNumber="$(web_pipe "$URL" | tr '=' '\n' | grep source | cut -d'"' -f2 | grep -v "iso\." | tr -d '-' | fv -c -Q | grep 2'[[:digit:]]' | fv -M )"
    else ReleaseNumber="$(web_pipe "$URL" | tr '=' '\n' | grep source | cut -d'"' -f2 | grep -v "iso\." | tr -d '-' | fv -c -Q | grep -v 2'[[:digit:]]' | fv -M )"
    fi
    # Minimal 32 bit discontinued @ 2025 09 and needs fv -M as sometimes has two editions in archive
    ISO="sparkylinux-${ReleaseNumber}-x86_64-${EDITION}.iso"
    HASH="$(web_pipe "${URL}/${ISO}.allsums.txt" | head -n 2 | grep 'iso' | cut -d' ' -f1)"
    echo "${URL}/${ISO}" "${HASH}"
}

## TWEAK to avoid spamming on test_all
function releases_spirallinux() {
    Spiral_Latest="$(web_pipe "https://sourceforge.net/projects/spirallinux/files/" | grep -s 'class="name' | fv -M -Q)"
    echo latest
}
function editions_spirallinux() {
    echo Plasma XFCE Mate LXQt Gnome Budgie Cinnamon Builder
}
function get_spirallinux() {
    local HASH="" ; local LATEST="$Spiral_Latest"
    [[ ! $LATEST ]] &&  LATEST="$(web_pipe "https://sourceforge.net/projects/spirallinux/files/" | grep -s 'class="name' | fv -M -Q)"
    local ISO="SpiralLinux_${EDITION}_${LATEST}_x86-64.iso"
    local URL="https://sourceforge.net/projects/spirallinux/files/${LATEST}"
    HASH=$(web_pipe 'https://sourceforge.net/projects/spirallinux/rss?path=/' | grep "${ISO}" | grep 'md5' | cut -d'<' -f3 | cut -d'>' -f2)
    echo "${URL}/${ISO}" "${HASH}"
}

## UPDATE, FIX and make dynamic
function releases_tinycore() {
    web_pipe "http://www.tinycorelinux.net/downloads.html" | grep archive | tr '<' '\n' | tr '>' '\n' | grep -e '.x' | grep -v href | sort -nr | head -n 2
}
function editions_tinycore() {
    echo Core TinyCore CorePlus CorePure64 TinyCorePure64
}
function get_tinycore() {
    local ARCH="x86"; local HASH= ; local URL= ; local ISO ; local IsoPoint=
    case "${EDITION}" in
        *Pure*) ARCH+="_64";;
    esac
    URL="http://www.tinycorelinux.net/${RELEASE}/${ARCH}/release"
    IsoPoint=$(web_pipe "$URL" | grep href | fv -M -Q)
    ISO="${EDITION}-${IsoPoint}.iso"
    HASH=$(web_pipe "${URL}/${ISO}.md5.txt" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## FIX hash checker - base is now 256
function get_trisquel() {
    local HASH="" ; local ISO="" ;local URL="https://mirrors.ocf.berkeley.edu/trisquel-images"
    case ${EDITION} in
        mate) ISO="trisquel_${RELEASE}_amd64.iso";;
        lxde) ISO="trisquel-mini_${RELEASE}_amd64.iso";;
        kde) ISO="triskel_${RELEASE}_amd64.iso";;
        sugar) ISO="trisquel-sugar_${RELEASE}_amd64.iso";;
    esac
    HASH=$(web_pipe "${URL}/${ISO}.sha256" | grep "${ISO}" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}


## IMPROVE make dynamic
function releases_truenas-scale() {
    web_pipe "https://www.truenas.com/download-truenas-community-edition/" | tr '<' '\n' | grep -s href | grep releasenotes |  grep NAS | cut -d'>' -f2 | fv -M -Q
}

## FIX ubuntu multiple hash entries - but not using 'tail -n 1' as in upstream, as could fail if order not ascending
function get_ubuntu-server() {
    local HASH="" ; local ISO="" ; local NAME="live-server" ; local URL="" ; local DATA="" ; local RelMax=
    if [[ "${RELEASE}" == "daily"* ]]; then URL="https://cdimage.ubuntu.com/${OS}/${RELEASE}/current"
    else URL="https://releases.ubuntu.com/${RELEASE}"
    fi
    case "${RELEASE}" in 14*|16*) NAME="server";;
    esac
    if web_check "${URL}/SHA256SUMS"; then
        RelMax="$( web_pipe "$URL" | tr '>' '\n' | grep 'href=' | grep iso | tr -d '-' | fv -M -Q)"
        DATA=$(web_pipe "${URL}/SHA256SUMS" | grep "${NAME}" | grep amd64 | grep iso | grep "$RelMax")
        ISO=$(cut -d'*' -f2 <<<"${DATA}")
        HASH=$(cut -d' ' -f1 <<<"${DATA}")
    else
        RelMax="$( web_pipe "$URL" | tr '>' '\n' | grep 'href=' | grep iso | tr -d '-' | fv -M -Q)"
        DATA=$(web_pipe "${URL}/MD5SUMS" | grep "${NAME}" | grep amd64 | grep iso | grep "$RelMax")
        ISO=$(cut -d' ' -f3 <<<"${DATA}")
        HASH=$(cut -d' ' -f1 <<<"${DATA}")
    fi
    if [[ "${RELEASE}" == "daily"* ]] || [ "${RELEASE}" == "dvd" ]; then
        zsync_get "${URL}/${ISO}" "${VM_PATH}" "${OS}-devel.iso"
        make_vm_config "${OS}-devel.iso"
    else
        web_get "${URL}/${ISO}" "${VM_PATH}"
        check_hash "${ISO}" "${HASH}"
        make_vm_config "${ISO}"
    fi
}
function get_ubuntu() {
    local ISO="" ; local HASH="" ; local URL=""; local DATA="" ; local RelMax=
    if [[ "${RELEASE}" == "daily"* ]] && [ "${OS}" == "xxubuntustudio" ]; then
        # Ubuntu Studio daily-live images are in the dvd directory  @ feb 2025 no longer the case
        RELEASE="dvd"
    fi
    if [[ "${RELEASE}" == "jammy-daily" ]]; then
        if [[ "${OS}" == "ubuntustudio" ]]; then URL="https://cdimage.ubuntu.com/${OS}/jammy/dvd/current"
        else URL="https://cdimage.ubuntu.com/${OS}/jammy/daily-live/current"
        fi
        VM_PATH="${OS}-jammy-live"
    elif [[ "${RELEASE}" == "daily"* ]] || [ "${RELEASE}" == "dvd" ]; then
        URL="https://cdimage.ubuntu.com/${OS}/${RELEASE}/current"
        VM_PATH="${OS}-${RELEASE}"
    elif [ "${OS}" == "ubuntu" ]; then
        URL="https://releases.ubuntu.com/${RELEASE}"
    else
        URL="https://cdimage.ubuntu.com/${OS}/releases/${RELEASE}/release"
    fi
    if web_check "${URL}/SHA256SUMS"; then
        RelMax="$( web_pipe "$URL" | tr '>' '\n' | grep 'href=' | grep iso | tr -d '-' | fv -M -Q)"
        DATA=$(web_pipe "${URL}/SHA256SUMS" | grep 'desktop\|dvd\|install' | grep amd64 | grep iso | grep -v "+mac" | grep "$RelMax")
        ISO=$(cut -d'*' -f2 <<<"${DATA}")
        HASH=$(cut -d' ' -f1 <<<"${DATA}")
    else
        RelMax="$( web_pipe "$URL" | tr '>' '\n' | grep 'href=' | grep iso | tr -d '-' | fv -M -Q)"
        DATA=$(web_pipe "${URL}/MD5SUMS" | grep 'desktop\|dvd\|install' | grep amd64 | grep iso | grep -v "+mac" | grep "$RelMax")
        ISO=$(cut -d'*' -f2 <<<"${DATA}")
        HASH=$(cut -d' ' -f1 <<<"${DATA}")
    fi
    if [ -z "${ISO}" ] || [ -z "${HASH}" ]; then
        echo "$(pretty_name "${OS}") ${RELEASE} is currently unavailable. Please select other OS/Release combination"
        exit 1
    fi
    if [[ "${RELEASE}" == "daily"* ]] || [ "${RELEASE}" == "dvd" ]; then
        zsync_get "${URL}/${ISO}" "${VM_PATH}" "${OS}-devel.iso"
        make_vm_config "${OS}-devel.iso"
    elif [[ "${RELEASE}" == "jammy-daily" ]]; then
        zsync_get "${URL}/${ISO}" "${VM_PATH}" "${OS}-jammy-live.iso"
        make_vm_config "${OS}-jammy-live.iso"
    else
        web_get "${URL}/${ISO}" "${VM_PATH}"
        check_hash "${ISO}" "${HASH}"
        make_vm_config "${ISO}"
    fi
}

## FIX invalid VOID folders (use 'current' only as some folders have variants)
function releases_void() {
    web_pipe "https://repo-default.voidlinux.org/live/current" | grep -e '<a href=' | grep x86 | grep 'base\.iso' | grep -v musl | cut -d'-' -f4 | tr -cd '[:graph:]'
 }
function get_void() {
    local HASH="" ; local ISO="" ; local URL="https://repo-default.voidlinux.org/live/$RELEASE"
    case ${EDITION} in
        glibc) ISO="void-live-x86_64-${RELEASE}-base.iso";;
        musl) ISO="void-live-x86_64-musl-${RELEASE}-base.iso";;
        xfce-glibc) ISO="void-live-x86_64-${RELEASE}-xfce.iso";;
        xfce-musl) ISO="void-live-x86_64-musl-${RELEASE}-xfce.iso";;
    esac
    HASH="$(web_pipe "${URL}/sha256sum.txt" | grep "${ISO}" | cut -d' ' -f4)"
    echo "${URL}/${ISO} ${HASH}"
}

## ADD 18 as in https://github.com/quickemu-project/quickemu/pull/1761
# but FIX missing lite64 with ver 18. REVIEW making dynamic?
function releases_zorin() {
    echo 18 17 16
}
function editions_zorin() {
    if [[ $RELEASE == "18" ]]; then echo "core64 education64"
    else echo "core64 lite64  education64"
    fi
}

##########################################

## 4: GUEST TYPE

# Needed only for special case instructions, such as non-iso
# Use for new qqX listed distros or for case overwrites
# Add in the format of "guest_type_${OS} ()"

##########################################

## 5: CONFIGURATION

# Needed only for special case instructions, such as needs legacy boot etc
# Use for new qqX listed distros or for case overwrites
# Add in the format of "config_${OS} ()"

##########################################

## 6: FINALIZING

# Needed only for special case instructions, such as decompression routines
# Use for new qqX listed distros or for case overwrites
# Add in the format of "finalize_${OS} ()"

##########################################

## 7: DOWNLOAD XL
# For special and oversized 'get' functions or "get_${OS} ()" overwrites, eg Windows or Mac
# Normally place 'get' functions next to releases and editions

function unattended_windows() {

  mkdir -p "${1}/unattended" 2>/dev/null

  RndSeq="$( (tr -cd 'b-zB-Z1-9' | tr -d 'eiouyEIOUY' | head -c 16) < /dev/urandom )"
  {
    echo "Admin  $RndSeq"
    echo; echo "# Password recorded to hand but OS isolated. May be changed ...."
  } > "${1}/Credentials.txt"
  # Strengthen: Quickemu uses Quickemu/Quickemu for Admin ....

  cat << 'EOF' > "${1}/unattended/autounattend.xml"
<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend"
  xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <!--
       For documentation on components:
       https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/unattend/
  -->
 <settings pass="offlineServicing">
    <component name="Microsoft-Windows-LUA-Settings" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <EnableLUA>false</EnableLUA>
    </component>
    <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <ComputerName>*</ComputerName>
    </component>
  </settings>

  <settings pass="generalize">
    <component name="Microsoft-Windows-PnPSysprep" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
      <PersistAllDeviceInstalls>true</PersistAllDeviceInstalls>
    </component>
    <component name="Microsoft-Windows-Security-SPP" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <SkipRearm>1</SkipRearm>
    </component>
  </settings>

  <settings pass="specialize">
    <component name="Microsoft-Windows-Security-SPP-UX" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <SkipAutoActivation>true</SkipAutoActivation>
    </component>
    <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <ComputerName>*</ComputerName>
      <OEMInformation>
        <Manufacturer>qqX Project</Manufacturer>
        <Model>qqX</Model>
        <SupportHours>24/7</SupportHours>
        <SupportPhone></SupportPhone>
        <SupportProvider>qqX Project</SupportProvider>
        <SupportURL>https://qqxproject.org</SupportURL>
      </OEMInformation>
      <OEMName>qqX Project</OEMName>
      <ProductKey>W269N-WFGWX-YVC9B-4J6C9-T83GX</ProductKey>
    </component>
    <component name="Microsoft-Windows-SQMApi" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <CEIPEnabled>0</CEIPEnabled>
    </component>
  </settings>

  <settings pass="windowsPE">
    <component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <Diagnostics>
        <OptIn>false</OptIn>
      </Diagnostics>
      <DiskConfiguration>
        <Disk wcm:action="add">
          <DiskID>0</DiskID>
          <WillWipeDisk>true</WillWipeDisk>
          <CreatePartitions>
            <!-- Windows RE Tools partition -->
            <CreatePartition wcm:action="add">
              <Order>1</Order>
              <Type>Primary</Type>
              <Size>256</Size>
            </CreatePartition>
            <!-- System partition (ESP) -->
            <CreatePartition wcm:action="add">
              <Order>2</Order>
              <Type>EFI</Type>
              <Size>128</Size>
            </CreatePartition>
            <!-- Microsoft reserved partition (MSR) -->
            <CreatePartition wcm:action="add">
              <Order>3</Order>
              <Type>MSR</Type>
              <Size>128</Size>
            </CreatePartition>
            <!-- Windows partition -->
            <CreatePartition wcm:action="add">
              <Order>4</Order>
              <Type>Primary</Type>
              <Extend>true</Extend>
            </CreatePartition>
          </CreatePartitions>
          <ModifyPartitions>
            <!-- Windows RE Tools partition -->
            <ModifyPartition wcm:action="add">
              <Order>1</Order>
              <PartitionID>1</PartitionID>
              <Label>WINRE</Label>
              <Format>NTFS</Format>
              <TypeID>DE94BBA4-06D1-4D40-A16A-BFD50179D6AC</TypeID>
            </ModifyPartition>
            <!-- System partition (ESP) -->
            <ModifyPartition wcm:action="add">
              <Order>2</Order>
              <PartitionID>2</PartitionID>
              <Label>System</Label>
              <Format>FAT32</Format>
            </ModifyPartition>
            <!-- MSR partition does not need to be modified -->
            <ModifyPartition wcm:action="add">
              <Order>3</Order>
              <PartitionID>3</PartitionID>
            </ModifyPartition>
            <!-- Windows partition -->
              <ModifyPartition wcm:action="add">
              <Order>4</Order>
              <PartitionID>4</PartitionID>
              <Label>Windows</Label>
              <Letter>C</Letter>
              <Format>NTFS</Format>
            </ModifyPartition>
          </ModifyPartitions>
        </Disk>
      </DiskConfiguration>
      <DynamicUpdate>
        <Enable>true</Enable>
        <WillShowUI>Never</WillShowUI>
      </DynamicUpdate>
      <ImageInstall>
        <OSImage>
          <InstallTo>
            <DiskID>0</DiskID>
            <PartitionID>4</PartitionID>
          </InstallTo>
          <InstallToAvailablePartition>false</InstallToAvailablePartition>
        </OSImage>
      </ImageInstall>
      <RunSynchronous>
        <RunSynchronousCommand wcm:action="add">
          <Order>1</Order>
          <Path>reg add HKLM\System\Setup\LabConfig /v BypassCPUCheck /t REG_DWORD /d 0x00000001 /f</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand wcm:action="add">
          <Order>2</Order>
          <Path>reg add HKLM\System\Setup\LabConfig /v BypassRAMCheck /t REG_DWORD /d 0x00000001 /f</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand wcm:action="add">
          <Order>3</Order>
          <Path>reg add HKLM\System\Setup\LabConfig /v BypassSecureBootCheck /t REG_DWORD /d 0x00000001 /f</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand wcm:action="add">
          <Order>4</Order>
          <Path>reg add HKLM\System\Setup\LabConfig /v BypassTPMCheck /t REG_DWORD /d 0x00000001 /f</Path>
        </RunSynchronousCommand>
      </RunSynchronous>
      <UpgradeData>
        <Upgrade>false</Upgrade>
        <WillShowUI>Never</WillShowUI>
      </UpgradeData>
      <UserData>
        <AcceptEula>true</AcceptEula>
        <FullName>Admin</FullName>
        <Organization>qqX Project</Organization>
        <!-- https://docs.microsoft.com/en-us/windows-server/get-started/kms-client-activation-keys -->
        <ProductKey>
          <Key>W269N-WFGWX-YVC9B-4J6C9-T83GX</Key>
          <WillShowUI>Never</WillShowUI>
        </ProductKey>
      </UserData>
    </component>

    <component name="Microsoft-Windows-PnpCustomizationsWinPE" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" processorArchitecture="amd64" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <!--
           This makes the VirtIO drivers available to Windows, assuming that
           the VirtIO driver disk is available as drive F: (keep as in qqX 1.12 fix)
           https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md

           Also see: https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/data/virtio-win-pre-installable-drivers-win-11.xml
           as it seems that NOT all drivers can be pre-installed ...
           BUT this link/file is from 'old-drivers' and there is no link to 'current-drivers'
           AND the given list is out of date, SO use a reduced list, importantly the scsi and stor which featured in the 1.12 fix.
           Also add split output, as the original only had w10 listed.
      -->
EOF

  if [[ $RELEASE == "11" ]]; then
    cat << 'EOF' >> "${1}/unattended/autounattend.xml"
      <DriverPaths>
        <PathAndCredentials wcm:action="add" wcm:keyValue="1">
          <Path>F:\vioscsi\w11\amd64</Path>
        </PathAndCredentials>
        <PathAndCredentials wcm:action="add" wcm:keyValue="2">
          <Path>F:\viostor\w11\amd64</Path>
        </PathAndCredentials>
      </DriverPaths>
EOF
  else
    cat << 'EOF' >> "${1}/unattended/autounattend.xml"
      <DriverPaths>
        <PathAndCredentials wcm:action="add" wcm:keyValue="1">
          <Path>F:\vioscsi\w10\amd64</Path>
        </PathAndCredentials>
        <PathAndCredentials wcm:action="add" wcm:keyValue="2">
          <Path>F:\viostor\w10\amd64</Path>
        </PathAndCredentials>
      </DriverPaths>
EOF
  fi

# shellcheck disable=SC2129
cat << 'EOF' >> "${1}/unattended/autounattend.xml"
    </component>
  </settings>

    <settings pass="oobeSystem">
    <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <AutoLogon>
        <Password>
EOF

  printf "%s" "          <Value>${RndSeq}</Value>" >> "${1}/unattended/autounattend.xml"

  cat << 'EOF' >> "${1}/unattended/autounattend.xml"
          <PlainText>true</PlainText>
        </Password>
        <Enabled>true</Enabled>
        <Username>Admin</Username>
      </AutoLogon>
      <DisableAutoDaylightTimeSet>false</DisableAutoDaylightTimeSet>
      <OOBE>
        <HideEULAPage>true</HideEULAPage>
        <HideLocalAccountScreen>true</HideLocalAccountScreen>
        <HideOEMRegistrationScreen>true</HideOEMRegistrationScreen>
        <HideOnlineAccountScreens>true</HideOnlineAccountScreens>
        <HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
        <NetworkLocation>Home</NetworkLocation>
        <ProtectYourPC>3</ProtectYourPC>
        <SkipUserOOBE>true</SkipUserOOBE>
        <SkipMachineOOBE>true</SkipMachineOOBE>
        <VMModeOptimizations>
          <SkipWinREInitialization>true</SkipWinREInitialization>
        </VMModeOptimizations>
      </OOBE>
      <UserAccounts>
        <LocalAccounts>
          <LocalAccount wcm:action="add">
            <Password>
EOF

  printf "%s" "          <Value>${RndSeq}</Value>" >> "${1}/unattended/autounattend.xml"

  cat << 'EOF' >> "${1}/unattended/autounattend.xml"
              <PlainText>true</PlainText>
            </Password>
            <Description>Admin</Description>
            <DisplayName>qqX community</DisplayName>
            <Group>Administrators</Group>
            <Name>Admin</Name>
          </LocalAccount>
        </LocalAccounts>
      </UserAccounts>
      <RegisteredOrganization>qqX Project</RegisteredOrganization>
      <RegisteredOwner>Admin</RegisteredOwner>
      <FirstLogonCommands>
        <SynchronousCommand wcm:action="add">
          <CommandLine>msiexec /i F:\virtio-win-gt-x64.msi /passive /qn</CommandLine>
          <Description>Install virtio drivers</Description>
          <Order>1</Order>
        </SynchronousCommand>
        <SynchronousCommand wcm:action="add">
          <CommandLine>msiexec /i E:\spice-vdagent-x64-0.10.0.msi /passive /qn</CommandLine>
          <Description>Install spice-vdagent SPICE agent</Description>
          <Order>2</Order>
        </SynchronousCommand>
       <SynchronousCommand wcm:action="add">
          <CommandLine>msiexec /i E:\spice-webdavd-x64-latest.msi /passive /qn</CommandLine>
          <Description>Install spice-webdavd file sharing agent</Description>
          <Order>3</Order>
        </SynchronousCommand>
        <SynchronousCommand wcm:action="add">
          <CommandLine>F:\virtio-win-guest-tools.exe /quiet</CommandLine>
          <Description>Install virtio tools</Description>
          <Order>4</Order>
        </SynchronousCommand>
        <SynchronousCommand wcm:action="add">
          <CommandLine>cmd /c POWERCFG -H OFF</CommandLine>
          <Description>Disable Hibernation</Description>
          <Order>5</Order>
        </SynchronousCommand>
        <SynchronousCommand wcm:action="add">
        <CommandLine>cmd /c net accounts /maxpwage:unlimited</CommandLine>
        <Description>Local account passwords never expire</Description>
        <Order>6</Order>
      </SynchronousCommand>
      </FirstLogonCommands>
    </component>
  </settings>
</unattend>
EOF

  echo "Downloading Spice drivers..."
  web_get https://www.spice-space.org/download/windows/spice-webdavd/spice-webdavd-x64-latest.msi "${VM_PATH}/unattended"
  web_get https://www.spice-space.org/download/windows/vdagent/vdagent-win-0.10.0/spice-vdagent-x64-0.10.0.msi "${VM_PATH}/unattended"

  # Spice downloads are difficult to enable dynamically as they are infrequent and differ in format.
  # However, a qqX based version notifier is possible:

  LatestSpiceAgent="$(web_pipe "https://www.spice-space.org/download/windows/vdagent" | tr '"' '\n' | grep -s vdagent | fv -Q -M)"
  if fv -qg "$LatestSpiceAgent 0.10.0" ; then
    echo; echo "A NEWER Spice agent has been found at https://www.spice-space.org/download/windows/vdagent"
    echo "but auto adjusting downloads are difficult to enable for the Spice website:"
    echo; echo "After the installation is finished, please manually update Spice to version $LatestSpiceAgent from inside Windows"
    echo; echo "Please report this at https://github.com/qqxproject/qqX/issues "
    echo "if a fix is not already in the development branch, so that a fix can be released."
  fi

  # REMOVE - UsbDk is for Hosts (aka clients), not for Guests.
  # See: https://www.ovirt.org/documentation/virtual_machine_management_guide/#sect-Configuring_USB_Devices
  # web_get https://www.spice-space.org/download/windows/usbdk/UsbDk_1.0.22_x64.msi "${VM_PATH}/unattended"

  # passwords never expire: See https://github.com/quickemu-project/quickemu/issues/1622

  echo "Making unattended.iso"
  mkisofs -quiet -J -R -input-charset utf-8 -o "${VM_PATH}/unattended.iso" "${VM_PATH}/unattended/"

}

##########################################

## OTHER FUNCTIONS
# The 'Mods' script gets read towards the end of the standard Quickget script via
# some lines added to the FreeSpirit branch. Any functions of the same name as in the original,
# here or above, will overwrite any of that name that have been previously declared.

# This particular section is more for qqX runtimes than Quickget itself. But you never know ...?
# A lot of these have already modded in the FreeSpirit branch but move here as they're NOW MUCH EASIER TO ADJUST

## TWEAK to make sure we wait for the check functions to return, as they might have to check the web.
function error_specify_release {
    show_os_info "${OS}"
    case ${OS} in
        *ubuntu-server*)
            echo -en " - Releases:\t"
            releases_ubuntu-server &
            wait "$!" ;;
        *ubuntu*)
            echo -en " - Releases:\t"
            releases_ubuntu &
            wait "$!" ;;
        *windows*)
            echo -en " - Releases:\t"
            "releases_${OS}" &
            wait "$!"
            echo -en " - Languages:\t"
            "languages_${OS}" &
            wait "$!"
            # shellcheck disable=SC2153
            echo "${I18NS[@]}" ;;
        *)
            echo -en " - Releases:\t"
            "releases_${OS}" | fmt -w 80 &
            wait "$!"
            if [[ $(type -t "editions_${OS}") == function ]]; then
                echo -en " - Editions:\t"
                "editions_${OS}" | fmt -w 80 &
                wait "$!"
            fi ;;
    esac
    echo -e "\nERROR! You must specify a release." ; exit 1
}

## TWEAK
# A lot of these have already modded in the FreeSpirit branch but move here as they're NOW MUCH EASIER TO ADJUST

# Download a SMALL file page, checksum etc from the web and pipe it to stdout  (not to confuse with 'web_get')
function web_pipe {
    local Args=("${@}") ; [[ ! "${Args[*]}" ]] && return 1
    if ! curl --disable -sLf --retry 8 --retry-max-time 4 --connect-timeout 4 --no-keepalive --max-time 30 "${Args[@]}"; then
        curl --disable -sLf --retry 6 --retry-max-time 6 --connect-timeout 6 --no-keepalive --max-time 30 "${Args[@]}"
    fi
}

# Download a JSON file from the web and pipe it to stdout
function web_pipe_json {
    local Args=("${@}") ; [[ ! "${Args[*]}" ]] && return 1
    if ! curl --disable -sLf --retry 8 --retry-max-time 4 --connect-timeout 4 --no-keepalive --max-time 30 --header "Accept: application/json" "${Args[@]}"; then
        curl --disable -sLf --retry 6 --retry-max-time 6 --connect-timeout 6 --no-keepalive --max-time 30 --header "Accept: application/json" "${Args[@]}"
    fi
}

## ADD
# Check the file headers. To be used for returns of 0 or 1 with pipe to log file,
function check_pipe {
    printf "" > "/tmp/qGet_check_pipe.txt"
    local Args=("${@}")
    if [[ ! "${Args[*]}" ]]; then
        [[ $ChkLog ]] && printf "\nERROR: Missing Args for function check_pipe\n" >> "$ChkLog"
        return 1
    fi
    curl --disable -sLf --head --retry 16 --retry-max-time 2 --connect-timeout 2 --no-keepalive --location-trusted --max-time 30 "${Args[@]}" > "/tmp/qGet_check_pipe.txt"
    if ! grep -si 'HTTP/' "/tmp/qGet_check_pipe.txt" | tail -n 1 | grep -q 200; then
        printf "" > "/tmp/qGet_check_pipe.txt"
        curl --disable -sLf --head --retry 8 --retry-max-time 4 --connect-timeout 4 --no-keepalive --location-trusted --max-time 30 "${Args[@]}" > "/tmp/qGet_check_pipe.txt"
    fi
    if grep -si 'HTTP/' "/tmp/qGet_check_pipe.txt" | tail -n 1 | grep -q 200; then return 0 ; else return 1 ; fi
}
# where HTTP/ 200 = success (with size data etc as readable) and 404 = not found = fail
# --location-trusted means extend secure connection to the mirror or to the CDN otherwise 302 redirects will lose https.
# --no-keepalive/--keepalive-time as we don't need much, and so we then move on cleanly and can drop any cookies, if possible

## TWEAK
# Check if a URL needs to be redirected and returns the final URL mirror or CDN
function web_redirect() {
    local REDIRECT_URL="" ; local URL="${1}"
    REDIRECT_URL=$(curl --disable -sLf --connect-timeout 4 --no-keepalive --location-trusted --max-time 6 --write-out '%{url_effective}' -o "/dev/null" "${URL}" | tr -cd '[:print:]')
    [[ ! $REDIRECT_URL ]] && REDIRECT_URL=$(curl --disable -sLf --connect-timeout 4 --keepalive-time 1 --location-trusted --max-time 8 --write-out '%{url_effective}' -o "/dev/null" "${URL}" | tr -cd '[:print:]')
    if [[ $REDIRECT_URL ]] && [[ $REDIRECT_URL != "${URL}" ]]; then echo "${REDIRECT_URL}"
    else echo "${URL}"
    fi
}

## TWEAK
# Download a file from the web, to storage
function web_get() {
    local CHECK="" ; local HEADERS=() ; local URL="${1}" ; local DIR="${2}" ; local FILE=""
    local USER_AGENT="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
    if [ -n "${3}" ]; then FILE="${3}"
    else FILE="${URL##*/}"
    fi
    # Process any URL redirections after the file name has been extracted
    URL=$(web_redirect "${URL}")
    # Process any headers
    while (( "$#" )); do
        if [ "${1}" == "--header" ]; then HEADERS+=("${1}" "${2}") ; shift 2
        else shift
        fi
    done
    # Test mode for ISO
    if [ "${OPERATION}" == "show" ]; then
        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
        exit 0
    elif [ "${OPERATION}" == "test" ]; then
        # CAUTION with current QuickGet, $RELEASE and $EDITION may be generated already.
        # Current behaviour is that QuickGet will route distros with editions through web_GET.
        # Others, such as Macos, have their own special routines.
        # Those without, go through web_CHECK.
        # CARE is also needed so that distro checks don't trigger background downloads.
        # The QuickGet VARIANT CONVOLUTIONS can have lots of twists and turns ....
        if [[ "$OS" != *ubuntu* ]]; then
            local HASH= ; local GetLine= ; GetLine=$(get_"${OS}" "$RELEASE" "$EDITION")
            # 'get_$OS' should output two args; a filepath URL, followed a checksum number
            #  but additionally add mirror URL, if available or possible, to check the state of the mirror service,
            #  noting that mirrors can block in the time gap between the location of a mirror URL and testing it.
            printf "%s" "$GetLine" > "/tmp/qGet-test-all-GetLine.txt"
            # Leave as mirror URL, if available from above, if Check Mirrors requested. Otherwise reset.
            [[ ! $CheckMirrors ]] && URL=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $1}')
            HASH=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $2}')
            [[ "$HASH" == *'://'* ]] && HASH=
        fi
        CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
        printf "Using webget > %s %s" "$CHECK" "$URL" > "/tmp/qGet_webget_report.txt"
        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}" "$HASH"
        exit 0
    elif [ "${OPERATION}" == "download" ]; then
        DIR="$(pwd)"
    fi

    if [ "${DIR}" != "$(pwd)" ] && ! mkdir -p "${DIR}" 2>/dev/null; then
        echo "ERROR: Unable to create directory ${DIR}" ; exit 1
    fi
    #  Allow qqX or any external process to pick up the FINALIZED VM-NAME
    # - avoids overwrites eg windows 'unattended'
    # - external proc should clear this file before starting so the grep test will function
    if ! grep -sq 'New_VM_InstanceName' "/tmp/qe_new_vm_name.txt" ; then
        printf "New_VM_InstanceName=\"%s\" \n" "$(basename "$DIR")" > "/tmp/qe_new_vm_name.txt"
    fi
    if [[ ${OS} != windows && ${OS} != macos && ${OS} != windows-server ]]; then
        echo "Downloading $(pretty_name "${OS}") ${RELEASE} ${EDITION}" ; echo "- URL: ${URL}"
    fi
    # Add retries to the standard Quickemu 4.9.x method:
    # --continue-at -  will continue/resume a previous file transfer but we need to make sure we actually have a connection to start with ...
    tput civis ; echo
    local CurlParallel=
    if [[ ! $Curl_NoPara ]] && grep -qs -e '--parallel' <<< "$(curl --help all)" ; then
        CurlParallel="--parallel" ; printf "  qqX multiplexed parallel download: \n\n"
    fi
    if ! curl --disable -Lf $CurlParallel --retry 500 --retry-connrefused --retry-max-time 3 --retry-delay 1 --progress-bar --continue-at - \
    --output "${DIR}/${FILE}" --user-agent "${USER_AGENT}" "${HEADERS[@]}" -- "${URL}"; then
        # qqX needs to take control here, use exit instead  # $CurlParallel - unquoted
        if pgrep qqX >/dev/null ; then echo ; tput cnorm ; exit
        else echo "ERROR: Failed to download ${URL} with curl." ; tput cnorm ; echo ; rm -f "${DIR}/${FILE}"
        fi
    fi
    tput cnorm ; echo
}


## TWEAK
function web_check {
    local HEADERS=() ; local URL="${1}"
    # Normally just a URL. Mac OS has URL as $1 then followed by repeated headers requests.
    while (( "$#" )); do
        if [ "${1}" == "--header" ]; then HEADERS+=("${1}" "${2}") ; shift 2
        else shift
        fi
    done
    # check is standard *.* filename or Ubuntu SUMS file, not an html web page or such ...
    printf "%s" "$URL" > "/tmp/qmod-dl-url"
    if [[ ! $URL ]]; then
        [[ $ChkLog ]] && printf "\nERROR: No URL > Possible initial lookup or server problem\n" >> "$ChkLog"
        return 1
    elif [[ "$(basename "$URL")" != *.* ]] && [[ "$(basename "$URL")" != *SUMS* ]]; then
        [[ $ChkLog ]] && printf "\nERROR: Non Conformant URL > Possible initial lookup or server problem \n" >> "$ChkLog"
        return 1
    fi
    # returns 0 or 1, plus check_pipe outputs header to log file "/tmp/qGet_check_pipe.txt"
    if check_pipe "${HEADERS[@]}" "${URL}" ; then return 0
    else return 1
    fi
}

## ADD hash check, plus some output variants
# Checks if 'get_$OS' is outputting a checksum and, if so, that it is correctly formatted
function test_result {
    local OS="${1}" ; local RELEASE="${2}"
    if [[ "$3" == *'://'* ]]; then
        local URL="${3}" ; local RESULT="${4}" ; local HASH="${5}" ; local HashTest= ; local HashLength="0"
    else
        local EDITION="${3}" ; local URL="${4}" ; local RESULT="${5}" ; local HASH="${6}" ; local HashTest= ; local HashLength="0"
    fi
    if [[ $EDITION ]]; then OS="${OS}-${RELEASE}-${EDITION}"
    else OS="${OS}-${RELEASE}"
    fi
    HASH="$(tr -cd '[:graph:]' <<< "$HASH")" ; [[ $HASH ]] && HashLength="${#HASH}"
    case $HashLength in
        32|40|64|128) HashTest="PASS" ;;
        0) HashTest="n/a" ;;
        *) HashTest="FAIL" ;;
    esac
    local OsShort="${OS:0:30}"
    if [[ $QuietOps ]]; then {
        if [[ ! $OS ]]; then printf "Missing OS data: FAIL\n"
        elif [[ "${RESULT}" ]]; then printf "Checksum: %-4s   Iso: %s   %-30s  %s  %s \n" "$HashTest" "${RESULT}" "${OsShort}" "${URL}" "$HASH"
        else printf "%-30s %s ERROR\n" "${OsShort}" "${URL}"
        fi } >> "$ChkLog"
    elif [[ $CompactOps ]]; then {
        if [[ ! $OS ]]; then printf "Missing OS data: FAIL\n"
        elif [[ "${RESULT}" ]]; then printf "Checksum: %-4s   Iso: %s   %-40s\n" "$HashTest" "${RESULT}" "${OS}"
        else printf "%-40s %s ERROR\n" "${OS}" "${URL}"
        fi } | tee -a "$ChkLog"
    else {
        if [[ ! $OS ]]; then printf "Missing OS data: FAIL\n"
        elif [[ "${RESULT}" ]]; then printf "Checksum: %-4s   Iso: %s   %-30s  %s  %s \n" "$HashTest" "${RESULT}" "${OsShort}" "${URL}" "$HASH"
        else printf "%-30s %s ERROR\n" "${OsShort}" "${URL}"
        fi } | tee -a "$ChkLog"
    fi
}

## TWEAK plus add extra tests and test output
function test_all {
    OS="${1}"
    local CHECK="" ; local FUNC="${OS}" ; local GetLine="" ; local URL="" ; local HASH="" ; local EDITION= ; local RELEASE=
    [[ "${OS}" == *ubuntu* ]] && [[ "${OS}" != "ubuntu-server" ]] &&  FUNC="ubuntu"
    if [[ $(type -t "releases_${OS}") == function ]]; then
        for RELEASE in $("releases_${FUNC}"); do
            if [[ $(type -t "editions_${OS}") == function ]]; then
                for EDITION in $(editions_"${OS}"); do
                    # 'get_$OS' should output two args; a filepath URL, followed a checksum number
                    #  but additionally add mirror URL, if available or possible, to check the state of the mirror service,
                    #  noting that mirrors can block in the time gap between the location of a mirror URL and testing it.
                    GetLine=$(get_"${OS}" "$RELEASE")
                    printf "%s" "$GetLine" > "/tmp/qGet-test-all-GetLine.txt"
                    URL=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $1}')
                    [[ ! $URL ]] && printf "\nERROR: No URL from function %s\n" "get_${OS} $RELEASE"
                    [[ $CheckMirrors ]] &&  URL=$(web_redirect "${URL}")
                    HASH=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $2}')
                    if [ "${OPERATION}" == "show" ]; then
                        [[ ! $URL ]] && printf "\nERROR: No URL from function %s\n" "get_${OS}"
                        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
                    elif [ "${OPERATION}" == "test" ]; then
                        CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
                        if [[ ! $CHECK ]]; then echo "$OS  $RELEASE  $EDITION  FAIL"
                        else test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}" "$HASH"
                        fi
                    fi
                done
                [[ ! $EDITION ]] && [[ $ChkLog ]] && printf "ERROR: %s  %-40s  >  Editions function FAIL \n" "$OS" "$RELEASE" >> "$ChkLog"
            elif [[ "${OS}" == "windows"* ]]; then
                # Caution with current Quickemu, --check windows with $2 (or/and $3) will trigger a windows download
                "languages_${OS}"
                for I18N in "${I18NS[@]}"; do
                    if [ "${OPERATION}" == "show" ]; then
                        test_result "${OS}" "${RELEASE}" "${I18N}" ""
                    elif [ "${OPERATION}" == "test" ]; then
                        test_result "${OS}" "${RELEASE}" "${I18N}" "${URL}" "SKIP"
                    fi
                done
                # Caution here, the get_$OS routines must run in subshells in order to loop properly
            elif [[ "${OS}" == "macos" ]]; then
                (get_macos)
            elif [ "${OS}" == "ubuntu-server" ]; then
                (get_ubuntu-server)
            elif [[ "${OS}" == *ubuntu* ]]; then
                (get_ubuntu)
            else
                URL=$(get_"${OS}" | cut -d' ' -f1 | head -n 1)
                if [ "${OPERATION}" == "show" ]; then
                    [[ ! $URL ]] && printf "\nERROR: No URL from function %s\n" "get_${OS}"
                    test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
                elif [ "${OPERATION}" == "test" ]; then
                    GetLine=$(get_"${OS}" "$RELEASE")
                    printf "%s" "$GetLine" > "/tmp/qGet-test-all-GetLine.txt"
                    URL=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $1}')
                    [[ ! $URL ]] && printf "\nERROR: No URL from function %s\n" "get_${OS} $RELEASE"
                    [[ $CheckMirrors ]] &&  URL=$(web_redirect "${URL}")
                    HASH=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $2}')
                    CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
                    if [[ ! $CHECK ]]; then echo "$OS  $RELEASE  $EDITION  FAIL"
                    else test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}" "$HASH"
                    fi
                fi
            fi
        done
        [[ ! $RELEASE ]] && [[ $ChkLog ]] && printf "ERROR: %s  >  Releases function FAIL \n" "$OS" >> "$ChkLog"
    fi
    # prints at end of every distro set - a full test can take half an hour
    printf "\n\n"
    [[ $SingleCheck ]] && return
    if [[ $CompactOps || $FullCheckOps ]]; then
        printf "[s] to stop/pause tests (at next distro break point)\n"
        read -t 0.1 -r  ChkPause
        printf "\n\n"
        if [[ $ChkPause == "s" || $ChkPause == "c" ]]; then
            ChkPause= ; read -r -t 0.1 ; read -r -t 0.1 ; read -r -t 0.1 ; read -r -t 0.1 ; read -r -t 0.1 ; read -r -t 0.1
            printf "Tests paused: \n\n[enter] to restart  [c] to conclude \n\n"
            read -rp ">  " ChkStop
            [[ $ChkStop == "c" ]] && exit
            printf "\n\nRestarting ...\n\n"
        fi
    fi
}

##########################################

## QUICKGET COMMANDS
# The 'Mods' script gets read towards the end of the standard Quickget script via lines added to the FreeSpirit branch.
# Case mods will either clear any listed args and set flags early, or will run something and exit here,
# effectively being able to bypass selected original Quickget case statements, or add new ones ...

QuietOps= ; CompactOps= ; FullCheckOps= ; CheckMirrors= ; SingleCheck=
printf "Webget NOT used\n" > "/tmp/qGet_webget_report.txt"

case "${1}" in
    --info-line)
        os_info "$2" ; exit 1
    ;;
    --rel-notes)
        distro_release_notes "$2" ; exit 1
    ;;
    --mirrors)
        CheckMirrors=1 ; shift
    ;;
    --full-check|--check|-check)
        FullCheckOps=1 ; ChkLog="/tmp/qGet_FullResult.txt" ; printf "" > "$ChkLog"
        OPERATION="test" ; shift
        [[ $1 == "--mirrors" ]] && CheckMirrors=1 && shift
        if [[ ! $1 ]]; then
            for OS in $(os_support); do
                os_supported ; test_all "${OS}"
            done
            printf "  Log file: \"%s\" \n\n" "$ChkLog"
            exit
        elif [[ ! $2 ]]; then
            printf "\n" ; SingleCheck=1
            os_supported ; test_all "${1}"
            printf "  Log file: \"%s\" \n\n" "$ChkLog"
            exit
        fi ;;
    --quiet-check|--compact-check)
        if [[ $1 == "--quiet-check" ]]; then
            QuietOps=1 ; ChkLog="/tmp/qGet_QuietResult.txt" ; printf "" > "$ChkLog"
        fi
        if [[ $1 == "--compact-check" ]]; then
            CompactOps=1 ; ChkLog="/tmp/qGet_CompactResult.txt" ; printf "" > "$ChkLog"
        fi
        OPERATION="test" ; shift
        [[ $1 == "--mirrors" ]] && CheckMirrors=1 && shift
        if [[ ! $1 ]]; then
            for OS in $(os_support); do
                os_supported ; test_all "${OS}"
            done
            [[ $CompactOps ]] && printf "  Log file: \"%s\" \n\n" "$ChkLog"
            exit
        elif [[ ! $2 ]]; then
            printf "\n" ; SingleCheck=1
            os_supported ; test_all "${1}"
            [[ $CompactOps ]] && printf "  Log file: \"%s\" \n\n" "$ChkLog"
            exit
        fi ;;
         # NB: 'TestLog' is the matching 'quick_reroute_get' var which runs in a separate process, with both using the same log files
    --help|-help|--h|-h)
        help_message
        printf "\n\nExtra qqX commands: \n\nfrom a terminal opened in a qqX 'built-in' folder"
        printf "\n\n----------------------------- ./quickget -------------------------------"
        printf "\n\n  --info-line       Output the OS info line in raw field separated format for alternative processing"
        printf "\n\n  --rel-notes       Output the additional release and installation notes, if supplied"
        printf "\n\n  --full-check      [os] [release] [edition] : Full Hash/Iso to StdOut, plus log to file \"/tmp/qGet_FullResult.txt\""
        printf "\n\n  --compact-check   [os] [release] [edition] : Short line StdOut, plus log to file \"/tmp/qGet_CompactResult.txt\""
        printf "\n\n  --quiet-check     [os] [release] [edition] : Only log check image URL(s) to file \"/tmp/qGet_QuietResult.txt\""
        printf "\n\n  --mirrors         Add-on for the above tests, to show info on possible mirror services. Omit for more generalized testing."
        printf "\n\n  Without a specified 'OS' will run a complete 'test_all' whilst with 'OS' will test all releases and editions of that specified."
        printf "\n\n  Lastly, 2 or 3 part final descriptor checks will route through 'web_get' and will output plain results, without a log filename reminder."
        printf "\n\n----------------------------------------------------------------------------------\n\n"
        exit 0 ;;

    # EXTRA qqX INTERNAL COMMANDS and FLAGS are also possibile:

    --curl-no-para)
        Curl_NoPara=1 ; shift
    ;;

esac

##########################################

## CODING STYLE  (as listed at the end of the main 'qqX' script)

#  A more MODERN BASH style of coding is used for qqX than that used for QuickEmu.

#  NOT TO WORRY if you are only familiar the older more POSIX styles, there are still plenty of options
#  for contributions to the quickemu built-ins, particularly with QuickGet which needs frequent updating.

#  VARIABLES should normally tend towards 'CamelCase' & FUNCTIONS should tend towards 'snake_case'.
#  Aim for clarity and contextual identity. Emphasis or separation underscoring & caps should be added where needed.

#  Modern editors, such as VS Code or Sublime have auto-suggesting which enables LongerMoreHelpfulVariableNames.

#  Also SHELLCHECK will NOT continuity follow all-caps variables either, even if SC2154 is enabled ...
#  https://en.wikipedia.org/wiki/Camel_case   https://en.wikipedia.org/wiki/Snake_case

#  Variables {don't} need to be braced unless using string manipulations or needing to stop vars from merging with other text.
#  Some of QuickEmu's variables can be very ambiguous eg. '$VERSION' but in some places have to be used.
#  Except for the .conf file, where they are lowercase, they are generally CAPS and very brief ...

#  BRACKETS:  if [[ $Foo ]] && [[ ! $Bar ]] ...   Posix Style is not needed:  if [ -n ${FOO} ] && [ -z ${bar} ] ....

#  The [[ double bracket ]] system is NOW the STANDARD METHOD in the Bash Manual.
#  See  https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-_005b_005b
#  Plus https://ss64.com/bash/test.html  And (older article) http://mywiki.wooledge.org/BashFAQ/031

#  Double bracket one-liners may be new to some people.
#  These statements are all the same:

FooVar=

if [ -n "${FooVar}" ]; then
    echo
    echo "  Hello "
    echo
fi

if [[ $FooVar ]]; then
    printf "\n\n  Hello \n\n"
fi

[[ $FooVar ]] && printf "\n\n  Hello \n\n"

#  COMMENTS: Add clarification or explanation to code, especially if the origin or meaning could be difficult to follow.

#  Add links to any how-to's that you used.  If you needed to check, then others may do also.
#  Let others follow what you are/were thinking at the time & give Bash beginners a chance too.
#  It makes it easier for everyone, especially later on.

#  SPACE:  Give your code some room to breathe. But also keep your code tight enough to view on smaller screens.
#  Place it into clear logic blocks. Make it easy to follow & easy to see what is happening.

#  SED, AWK and REGEX:  Commands can very easily finish up as lines of indecipherable hieroglyphics.
#  If you must use them, keep things very simple & explain the sections.
#  Where possible use Bash's string manipulations instead.   See: http://mywiki.wooledge.org/BashFAQ/100

#  ECHO: Beyond basic one-liners, the use of printf should generally be preferred.  See https://ss64.com/bash/printf.html
#  However & specifically, echo within the vm boot control section of the qqX script *must* be avoided
#  as an echo trap is used to tee quickemu screen output to the qqX boot log.

#  All code should be SHELLCHECK linted & disables avoided where possible.
#  The VS Code shellcheck extension works well if set to 'check-on-save'.


# https://code.visualstudio.com/  (recommended)
# vim:tabstop=4:shiftwidth=4:expandtab